// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package control_test

import (
	"context"
	"github.com/newhook/co/internal/control"
	"github.com/newhook/co/internal/project"
	"io"
	"sync"
)

// Ensure, that OrchestratorSpawnerMock does implement control.OrchestratorSpawner.
// If this is not the case, regenerate this file with moq.
var _ control.OrchestratorSpawner = &OrchestratorSpawnerMock{}

// OrchestratorSpawnerMock is a mock implementation of control.OrchestratorSpawner.
//
//	func TestSomethingThatUsesOrchestratorSpawner(t *testing.T) {
//
//		// make and configure a mocked control.OrchestratorSpawner
//		mockedOrchestratorSpawner := &OrchestratorSpawnerMock{
//			SpawnWorkOrchestratorFunc: func(ctx context.Context, workID string, projectName string, workDir string, friendlyName string, w io.Writer) error {
//				panic("mock out the SpawnWorkOrchestrator method")
//			},
//		}
//
//		// use mockedOrchestratorSpawner in code that requires control.OrchestratorSpawner
//		// and then make assertions.
//
//	}
type OrchestratorSpawnerMock struct {
	// SpawnWorkOrchestratorFunc mocks the SpawnWorkOrchestrator method.
	SpawnWorkOrchestratorFunc func(ctx context.Context, workID string, projectName string, workDir string, friendlyName string, w io.Writer) error

	// calls tracks calls to the methods.
	calls struct {
		// SpawnWorkOrchestrator holds details about calls to the SpawnWorkOrchestrator method.
		SpawnWorkOrchestrator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjectName is the projectName argument value.
			ProjectName string
			// WorkDir is the workDir argument value.
			WorkDir string
			// FriendlyName is the friendlyName argument value.
			FriendlyName string
			// W is the w argument value.
			W io.Writer
		}
	}
	lockSpawnWorkOrchestrator sync.RWMutex
}

// SpawnWorkOrchestrator calls SpawnWorkOrchestratorFunc.
func (mock *OrchestratorSpawnerMock) SpawnWorkOrchestrator(ctx context.Context, workID string, projectName string, workDir string, friendlyName string, w io.Writer) error {
	callInfo := struct {
		Ctx          context.Context
		WorkID       string
		ProjectName  string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}{
		Ctx:          ctx,
		WorkID:       workID,
		ProjectName:  projectName,
		WorkDir:      workDir,
		FriendlyName: friendlyName,
		W:            w,
	}
	mock.lockSpawnWorkOrchestrator.Lock()
	mock.calls.SpawnWorkOrchestrator = append(mock.calls.SpawnWorkOrchestrator, callInfo)
	mock.lockSpawnWorkOrchestrator.Unlock()
	if mock.SpawnWorkOrchestratorFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SpawnWorkOrchestratorFunc(ctx, workID, projectName, workDir, friendlyName, w)
}

// SpawnWorkOrchestratorCalls gets all the calls that were made to SpawnWorkOrchestrator.
// Check the length with:
//
//	len(mockedOrchestratorSpawner.SpawnWorkOrchestratorCalls())
func (mock *OrchestratorSpawnerMock) SpawnWorkOrchestratorCalls() []struct {
	Ctx          context.Context
	WorkID       string
	ProjectName  string
	WorkDir      string
	FriendlyName string
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		WorkID       string
		ProjectName  string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}
	mock.lockSpawnWorkOrchestrator.RLock()
	calls = mock.calls.SpawnWorkOrchestrator
	mock.lockSpawnWorkOrchestrator.RUnlock()
	return calls
}

// Ensure, that WorkDestroyerMock does implement control.WorkDestroyer.
// If this is not the case, regenerate this file with moq.
var _ control.WorkDestroyer = &WorkDestroyerMock{}

// WorkDestroyerMock is a mock implementation of control.WorkDestroyer.
//
//	func TestSomethingThatUsesWorkDestroyer(t *testing.T) {
//
//		// make and configure a mocked control.WorkDestroyer
//		mockedWorkDestroyer := &WorkDestroyerMock{
//			DestroyWorkFunc: func(ctx context.Context, proj *project.Project, workID string, w io.Writer) error {
//				panic("mock out the DestroyWork method")
//			},
//		}
//
//		// use mockedWorkDestroyer in code that requires control.WorkDestroyer
//		// and then make assertions.
//
//	}
type WorkDestroyerMock struct {
	// DestroyWorkFunc mocks the DestroyWork method.
	DestroyWorkFunc func(ctx context.Context, proj *project.Project, workID string, w io.Writer) error

	// calls tracks calls to the methods.
	calls struct {
		// DestroyWork holds details about calls to the DestroyWork method.
		DestroyWork []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Proj is the proj argument value.
			Proj *project.Project
			// WorkID is the workID argument value.
			WorkID string
			// W is the w argument value.
			W io.Writer
		}
	}
	lockDestroyWork sync.RWMutex
}

// DestroyWork calls DestroyWorkFunc.
func (mock *WorkDestroyerMock) DestroyWork(ctx context.Context, proj *project.Project, workID string, w io.Writer) error {
	callInfo := struct {
		Ctx    context.Context
		Proj   *project.Project
		WorkID string
		W      io.Writer
	}{
		Ctx:    ctx,
		Proj:   proj,
		WorkID: workID,
		W:      w,
	}
	mock.lockDestroyWork.Lock()
	mock.calls.DestroyWork = append(mock.calls.DestroyWork, callInfo)
	mock.lockDestroyWork.Unlock()
	if mock.DestroyWorkFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DestroyWorkFunc(ctx, proj, workID, w)
}

// DestroyWorkCalls gets all the calls that were made to DestroyWork.
// Check the length with:
//
//	len(mockedWorkDestroyer.DestroyWorkCalls())
func (mock *WorkDestroyerMock) DestroyWorkCalls() []struct {
	Ctx    context.Context
	Proj   *project.Project
	WorkID string
	W      io.Writer
} {
	var calls []struct {
		Ctx    context.Context
		Proj   *project.Project
		WorkID string
		W      io.Writer
	}
	mock.lockDestroyWork.RLock()
	calls = mock.calls.DestroyWork
	mock.lockDestroyWork.RUnlock()
	return calls
}
