// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: dependencies.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const getAllIssueIDs = `-- name: GetAllIssueIDs :many
SELECT id FROM issues
WHERE deleted_at IS NULL
  AND status != 'tombstone'
`

func (q *Queries) GetAllIssueIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getAllIssueIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependenciesForIssues = `-- name: GetDependenciesForIssues :many
SELECT
    d.issue_id,
    d.depends_on_id,
    d.type,
    i.id,
    i.title,
    i.description,
    i.status,
    i.priority,
    i.issue_type,
    i.created_at,
    i.updated_at,
    i.closed_at
FROM dependencies d
INNER JOIN issues i ON d.depends_on_id = i.id
WHERE d.issue_id IN (/*SLICE:issue_ids*/?)
  AND i.deleted_at IS NULL
  AND i.status != 'tombstone'
`

type GetDependenciesForIssuesRow struct {
	IssueID     string       `json:"issue_id"`
	DependsOnID string       `json:"depends_on_id"`
	Type        string       `json:"type"`
	ID          string       `json:"id"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Status      string       `json:"status"`
	Priority    int64        `json:"priority"`
	IssueType   string       `json:"issue_type"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	ClosedAt    sql.NullTime `json:"closed_at"`
}

func (q *Queries) GetDependenciesForIssues(ctx context.Context, issueIds []string) ([]GetDependenciesForIssuesRow, error) {
	query := getDependenciesForIssues
	var queryParams []interface{}
	if len(issueIds) > 0 {
		for _, v := range issueIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:issue_ids*/?", strings.Repeat(",?", len(issueIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:issue_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDependenciesForIssuesRow{}
	for rows.Next() {
		var i GetDependenciesForIssuesRow
		if err := rows.Scan(
			&i.IssueID,
			&i.DependsOnID,
			&i.Type,
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependentsForIssues = `-- name: GetDependentsForIssues :many
SELECT
    d.issue_id,
    d.depends_on_id,
    d.type,
    i.id,
    i.title,
    i.description,
    i.status,
    i.priority,
    i.issue_type,
    i.created_at,
    i.updated_at,
    i.closed_at
FROM dependencies d
INNER JOIN issues i ON d.issue_id = i.id
WHERE d.depends_on_id IN (/*SLICE:depends_on_ids*/?)
  AND i.deleted_at IS NULL
  AND i.status != 'tombstone'
`

type GetDependentsForIssuesRow struct {
	IssueID     string       `json:"issue_id"`
	DependsOnID string       `json:"depends_on_id"`
	Type        string       `json:"type"`
	ID          string       `json:"id"`
	Title       string       `json:"title"`
	Description string       `json:"description"`
	Status      string       `json:"status"`
	Priority    int64        `json:"priority"`
	IssueType   string       `json:"issue_type"`
	CreatedAt   time.Time    `json:"created_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	ClosedAt    sql.NullTime `json:"closed_at"`
}

func (q *Queries) GetDependentsForIssues(ctx context.Context, dependsOnIds []string) ([]GetDependentsForIssuesRow, error) {
	query := getDependentsForIssues
	var queryParams []interface{}
	if len(dependsOnIds) > 0 {
		for _, v := range dependsOnIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:depends_on_ids*/?", strings.Repeat(",?", len(dependsOnIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:depends_on_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDependentsForIssuesRow{}
	for rows.Next() {
		var i GetDependentsForIssuesRow
		if err := rows.Scan(
			&i.IssueID,
			&i.DependsOnID,
			&i.Type,
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssueIDsByStatus = `-- name: GetIssueIDsByStatus :many
SELECT id FROM issues
WHERE deleted_at IS NULL
  AND status != 'tombstone'
  AND status = ?
`

func (q *Queries) GetIssueIDsByStatus(ctx context.Context, status string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getIssueIDsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIssuesByIDs = `-- name: GetIssuesByIDs :many
SELECT id, content_hash, title, description, design, acceptance_criteria, notes, status, priority, issue_type, assignee, estimated_minutes, created_at, created_by, owner, updated_at, closed_at, closed_by_session, external_ref, compaction_level, compacted_at, compacted_at_commit, original_size, deleted_at, deleted_by, delete_reason, original_type, sender, ephemeral, pinned, is_template, crystallizes, mol_type, work_type, quality_score, source_system, event_kind, actor, target, payload, source_repo, close_reason, await_type, await_id, timeout_ns, waiters, hook_bead, role_bead, agent_state, last_activity, role_type, rig, due_at, defer_until FROM issues
WHERE id IN (/*SLICE:ids*/?)
  AND deleted_at IS NULL
  AND status != 'tombstone'
`

func (q *Queries) GetIssuesByIDs(ctx context.Context, ids []string) ([]Issue, error) {
	query := getIssuesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Issue{}
	for rows.Next() {
		var i Issue
		if err := rows.Scan(
			&i.ID,
			&i.ContentHash,
			&i.Title,
			&i.Description,
			&i.Design,
			&i.AcceptanceCriteria,
			&i.Notes,
			&i.Status,
			&i.Priority,
			&i.IssueType,
			&i.Assignee,
			&i.EstimatedMinutes,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.Owner,
			&i.UpdatedAt,
			&i.ClosedAt,
			&i.ClosedBySession,
			&i.ExternalRef,
			&i.CompactionLevel,
			&i.CompactedAt,
			&i.CompactedAtCommit,
			&i.OriginalSize,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.DeleteReason,
			&i.OriginalType,
			&i.Sender,
			&i.Ephemeral,
			&i.Pinned,
			&i.IsTemplate,
			&i.Crystallizes,
			&i.MolType,
			&i.WorkType,
			&i.QualityScore,
			&i.SourceSystem,
			&i.EventKind,
			&i.Actor,
			&i.Target,
			&i.Payload,
			&i.SourceRepo,
			&i.CloseReason,
			&i.AwaitType,
			&i.AwaitID,
			&i.TimeoutNs,
			&i.Waiters,
			&i.HookBead,
			&i.RoleBead,
			&i.AgentState,
			&i.LastActivity,
			&i.RoleType,
			&i.Rig,
			&i.DueAt,
			&i.DeferUntil,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
