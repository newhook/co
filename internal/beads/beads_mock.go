// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package beads

import (
	"context"
	"sync"
)

// Ensure, that BeadsCLIMock does implement CLI.
// If this is not the case, regenerate this file with moq.
var _ CLI = &BeadsCLIMock{}

// BeadsCLIMock is a mock implementation of CLI.
//
//	func TestSomethingThatUsesCLI(t *testing.T) {
//
//		// make and configure a mocked CLI
//		mockedCLI := &BeadsCLIMock{
//			AddCommentFunc: func(ctx context.Context, beadID string, comment string) error {
//				panic("mock out the AddComment method")
//			},
//			AddDependencyFunc: func(ctx context.Context, beadID string, dependsOnID string) error {
//				panic("mock out the AddDependency method")
//			},
//			AddLabelsFunc: func(ctx context.Context, beadID string, labels []string) error {
//				panic("mock out the AddLabels method")
//			},
//			CloseFunc: func(ctx context.Context, beadID string) error {
//				panic("mock out the Close method")
//			},
//			CreateFunc: func(ctx context.Context, opts CreateOptions) (string, error) {
//				panic("mock out the Create method")
//			},
//			ReopenFunc: func(ctx context.Context, beadID string) error {
//				panic("mock out the Reopen method")
//			},
//			SetExternalRefFunc: func(ctx context.Context, beadID string, externalRef string) error {
//				panic("mock out the SetExternalRef method")
//			},
//			UpdateFunc: func(ctx context.Context, beadID string, opts UpdateOptions) error {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedCLI in code that requires CLI
//		// and then make assertions.
//
//	}
type BeadsCLIMock struct {
	// AddCommentFunc mocks the AddComment method.
	AddCommentFunc func(ctx context.Context, beadID string, comment string) error

	// AddDependencyFunc mocks the AddDependency method.
	AddDependencyFunc func(ctx context.Context, beadID string, dependsOnID string) error

	// AddLabelsFunc mocks the AddLabels method.
	AddLabelsFunc func(ctx context.Context, beadID string, labels []string) error

	// CloseFunc mocks the Close method.
	CloseFunc func(ctx context.Context, beadID string) error

	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, opts CreateOptions) (string, error)

	// ReopenFunc mocks the Reopen method.
	ReopenFunc func(ctx context.Context, beadID string) error

	// SetExternalRefFunc mocks the SetExternalRef method.
	SetExternalRefFunc func(ctx context.Context, beadID string, externalRef string) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, beadID string, opts UpdateOptions) error

	// calls tracks calls to the methods.
	calls struct {
		// AddComment holds details about calls to the AddComment method.
		AddComment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// Comment is the comment argument value.
			Comment string
		}
		// AddDependency holds details about calls to the AddDependency method.
		AddDependency []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// DependsOnID is the dependsOnID argument value.
			DependsOnID string
		}
		// AddLabels holds details about calls to the AddLabels method.
		AddLabels []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// Labels is the labels argument value.
			Labels []string
		}
		// Close holds details about calls to the Close method.
		Close []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Opts is the opts argument value.
			Opts CreateOptions
		}
		// Reopen holds details about calls to the Reopen method.
		Reopen []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
		}
		// SetExternalRef holds details about calls to the SetExternalRef method.
		SetExternalRef []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// ExternalRef is the externalRef argument value.
			ExternalRef string
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// Opts is the opts argument value.
			Opts UpdateOptions
		}
	}
	lockAddComment     sync.RWMutex
	lockAddDependency  sync.RWMutex
	lockAddLabels      sync.RWMutex
	lockClose          sync.RWMutex
	lockCreate         sync.RWMutex
	lockReopen         sync.RWMutex
	lockSetExternalRef sync.RWMutex
	lockUpdate         sync.RWMutex
}

// AddComment calls AddCommentFunc.
func (mock *BeadsCLIMock) AddComment(ctx context.Context, beadID string, comment string) error {
	callInfo := struct {
		Ctx     context.Context
		BeadID  string
		Comment string
	}{
		Ctx:     ctx,
		BeadID:  beadID,
		Comment: comment,
	}
	mock.lockAddComment.Lock()
	mock.calls.AddComment = append(mock.calls.AddComment, callInfo)
	mock.lockAddComment.Unlock()
	if mock.AddCommentFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AddCommentFunc(ctx, beadID, comment)
}

// AddCommentCalls gets all the calls that were made to AddComment.
// Check the length with:
//
//	len(mockedCLI.AddCommentCalls())
func (mock *BeadsCLIMock) AddCommentCalls() []struct {
	Ctx     context.Context
	BeadID  string
	Comment string
} {
	var calls []struct {
		Ctx     context.Context
		BeadID  string
		Comment string
	}
	mock.lockAddComment.RLock()
	calls = mock.calls.AddComment
	mock.lockAddComment.RUnlock()
	return calls
}

// AddDependency calls AddDependencyFunc.
func (mock *BeadsCLIMock) AddDependency(ctx context.Context, beadID string, dependsOnID string) error {
	callInfo := struct {
		Ctx         context.Context
		BeadID      string
		DependsOnID string
	}{
		Ctx:         ctx,
		BeadID:      beadID,
		DependsOnID: dependsOnID,
	}
	mock.lockAddDependency.Lock()
	mock.calls.AddDependency = append(mock.calls.AddDependency, callInfo)
	mock.lockAddDependency.Unlock()
	if mock.AddDependencyFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AddDependencyFunc(ctx, beadID, dependsOnID)
}

// AddDependencyCalls gets all the calls that were made to AddDependency.
// Check the length with:
//
//	len(mockedCLI.AddDependencyCalls())
func (mock *BeadsCLIMock) AddDependencyCalls() []struct {
	Ctx         context.Context
	BeadID      string
	DependsOnID string
} {
	var calls []struct {
		Ctx         context.Context
		BeadID      string
		DependsOnID string
	}
	mock.lockAddDependency.RLock()
	calls = mock.calls.AddDependency
	mock.lockAddDependency.RUnlock()
	return calls
}

// AddLabels calls AddLabelsFunc.
func (mock *BeadsCLIMock) AddLabels(ctx context.Context, beadID string, labels []string) error {
	callInfo := struct {
		Ctx    context.Context
		BeadID string
		Labels []string
	}{
		Ctx:    ctx,
		BeadID: beadID,
		Labels: labels,
	}
	mock.lockAddLabels.Lock()
	mock.calls.AddLabels = append(mock.calls.AddLabels, callInfo)
	mock.lockAddLabels.Unlock()
	if mock.AddLabelsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.AddLabelsFunc(ctx, beadID, labels)
}

// AddLabelsCalls gets all the calls that were made to AddLabels.
// Check the length with:
//
//	len(mockedCLI.AddLabelsCalls())
func (mock *BeadsCLIMock) AddLabelsCalls() []struct {
	Ctx    context.Context
	BeadID string
	Labels []string
} {
	var calls []struct {
		Ctx    context.Context
		BeadID string
		Labels []string
	}
	mock.lockAddLabels.RLock()
	calls = mock.calls.AddLabels
	mock.lockAddLabels.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *BeadsCLIMock) Close(ctx context.Context, beadID string) error {
	callInfo := struct {
		Ctx    context.Context
		BeadID string
	}{
		Ctx:    ctx,
		BeadID: beadID,
	}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseFunc(ctx, beadID)
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedCLI.CloseCalls())
func (mock *BeadsCLIMock) CloseCalls() []struct {
	Ctx    context.Context
	BeadID string
} {
	var calls []struct {
		Ctx    context.Context
		BeadID string
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *BeadsCLIMock) Create(ctx context.Context, opts CreateOptions) (string, error) {
	callInfo := struct {
		Ctx  context.Context
		Opts CreateOptions
	}{
		Ctx:  ctx,
		Opts: opts,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			sOut   string
			errOut error
		)
		return sOut, errOut
	}
	return mock.CreateFunc(ctx, opts)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedCLI.CreateCalls())
func (mock *BeadsCLIMock) CreateCalls() []struct {
	Ctx  context.Context
	Opts CreateOptions
} {
	var calls []struct {
		Ctx  context.Context
		Opts CreateOptions
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Reopen calls ReopenFunc.
func (mock *BeadsCLIMock) Reopen(ctx context.Context, beadID string) error {
	callInfo := struct {
		Ctx    context.Context
		BeadID string
	}{
		Ctx:    ctx,
		BeadID: beadID,
	}
	mock.lockReopen.Lock()
	mock.calls.Reopen = append(mock.calls.Reopen, callInfo)
	mock.lockReopen.Unlock()
	if mock.ReopenFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ReopenFunc(ctx, beadID)
}

// ReopenCalls gets all the calls that were made to Reopen.
// Check the length with:
//
//	len(mockedCLI.ReopenCalls())
func (mock *BeadsCLIMock) ReopenCalls() []struct {
	Ctx    context.Context
	BeadID string
} {
	var calls []struct {
		Ctx    context.Context
		BeadID string
	}
	mock.lockReopen.RLock()
	calls = mock.calls.Reopen
	mock.lockReopen.RUnlock()
	return calls
}

// SetExternalRef calls SetExternalRefFunc.
func (mock *BeadsCLIMock) SetExternalRef(ctx context.Context, beadID string, externalRef string) error {
	callInfo := struct {
		Ctx         context.Context
		BeadID      string
		ExternalRef string
	}{
		Ctx:         ctx,
		BeadID:      beadID,
		ExternalRef: externalRef,
	}
	mock.lockSetExternalRef.Lock()
	mock.calls.SetExternalRef = append(mock.calls.SetExternalRef, callInfo)
	mock.lockSetExternalRef.Unlock()
	if mock.SetExternalRefFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetExternalRefFunc(ctx, beadID, externalRef)
}

// SetExternalRefCalls gets all the calls that were made to SetExternalRef.
// Check the length with:
//
//	len(mockedCLI.SetExternalRefCalls())
func (mock *BeadsCLIMock) SetExternalRefCalls() []struct {
	Ctx         context.Context
	BeadID      string
	ExternalRef string
} {
	var calls []struct {
		Ctx         context.Context
		BeadID      string
		ExternalRef string
	}
	mock.lockSetExternalRef.RLock()
	calls = mock.calls.SetExternalRef
	mock.lockSetExternalRef.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *BeadsCLIMock) Update(ctx context.Context, beadID string, opts UpdateOptions) error {
	callInfo := struct {
		Ctx    context.Context
		BeadID string
		Opts   UpdateOptions
	}{
		Ctx:    ctx,
		BeadID: beadID,
		Opts:   opts,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	if mock.UpdateFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpdateFunc(ctx, beadID, opts)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedCLI.UpdateCalls())
func (mock *BeadsCLIMock) UpdateCalls() []struct {
	Ctx    context.Context
	BeadID string
	Opts   UpdateOptions
} {
	var calls []struct {
		Ctx    context.Context
		BeadID string
		Opts   UpdateOptions
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that BeadsReaderMock does implement Reader.
// If this is not the case, regenerate this file with moq.
var _ Reader = &BeadsReaderMock{}

// BeadsReaderMock is a mock implementation of Reader.
//
//	func TestSomethingThatUsesReader(t *testing.T) {
//
//		// make and configure a mocked Reader
//		mockedReader := &BeadsReaderMock{
//			GetBeadFunc: func(ctx context.Context, id string) (*BeadWithDeps, error) {
//				panic("mock out the GetBead method")
//			},
//			GetBeadWithChildrenFunc: func(ctx context.Context, id string) ([]Bead, error) {
//				panic("mock out the GetBeadWithChildren method")
//			},
//			GetBeadsWithDepsFunc: func(ctx context.Context, beadIDs []string) (*BeadsWithDepsResult, error) {
//				panic("mock out the GetBeadsWithDeps method")
//			},
//			GetReadyBeadsFunc: func(ctx context.Context) ([]Bead, error) {
//				panic("mock out the GetReadyBeads method")
//			},
//			GetTransitiveDependenciesFunc: func(ctx context.Context, id string) ([]Bead, error) {
//				panic("mock out the GetTransitiveDependencies method")
//			},
//			ListBeadsFunc: func(ctx context.Context, status string) ([]Bead, error) {
//				panic("mock out the ListBeads method")
//			},
//		}
//
//		// use mockedReader in code that requires Reader
//		// and then make assertions.
//
//	}
type BeadsReaderMock struct {
	// GetBeadFunc mocks the GetBead method.
	GetBeadFunc func(ctx context.Context, id string) (*BeadWithDeps, error)

	// GetBeadWithChildrenFunc mocks the GetBeadWithChildren method.
	GetBeadWithChildrenFunc func(ctx context.Context, id string) ([]Bead, error)

	// GetBeadsWithDepsFunc mocks the GetBeadsWithDeps method.
	GetBeadsWithDepsFunc func(ctx context.Context, beadIDs []string) (*BeadsWithDepsResult, error)

	// GetReadyBeadsFunc mocks the GetReadyBeads method.
	GetReadyBeadsFunc func(ctx context.Context) ([]Bead, error)

	// GetTransitiveDependenciesFunc mocks the GetTransitiveDependencies method.
	GetTransitiveDependenciesFunc func(ctx context.Context, id string) ([]Bead, error)

	// ListBeadsFunc mocks the ListBeads method.
	ListBeadsFunc func(ctx context.Context, status string) ([]Bead, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetBead holds details about calls to the GetBead method.
		GetBead []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetBeadWithChildren holds details about calls to the GetBeadWithChildren method.
		GetBeadWithChildren []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// GetBeadsWithDeps holds details about calls to the GetBeadsWithDeps method.
		GetBeadsWithDeps []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadIDs is the beadIDs argument value.
			BeadIDs []string
		}
		// GetReadyBeads holds details about calls to the GetReadyBeads method.
		GetReadyBeads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetTransitiveDependencies holds details about calls to the GetTransitiveDependencies method.
		GetTransitiveDependencies []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID string
		}
		// ListBeads holds details about calls to the ListBeads method.
		ListBeads []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status string
		}
	}
	lockGetBead                   sync.RWMutex
	lockGetBeadWithChildren       sync.RWMutex
	lockGetBeadsWithDeps          sync.RWMutex
	lockGetReadyBeads             sync.RWMutex
	lockGetTransitiveDependencies sync.RWMutex
	lockListBeads                 sync.RWMutex
}

// GetBead calls GetBeadFunc.
func (mock *BeadsReaderMock) GetBead(ctx context.Context, id string) (*BeadWithDeps, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBead.Lock()
	mock.calls.GetBead = append(mock.calls.GetBead, callInfo)
	mock.lockGetBead.Unlock()
	if mock.GetBeadFunc == nil {
		var (
			beadWithDepsOut *BeadWithDeps
			errOut          error
		)
		return beadWithDepsOut, errOut
	}
	return mock.GetBeadFunc(ctx, id)
}

// GetBeadCalls gets all the calls that were made to GetBead.
// Check the length with:
//
//	len(mockedReader.GetBeadCalls())
func (mock *BeadsReaderMock) GetBeadCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetBead.RLock()
	calls = mock.calls.GetBead
	mock.lockGetBead.RUnlock()
	return calls
}

// GetBeadWithChildren calls GetBeadWithChildrenFunc.
func (mock *BeadsReaderMock) GetBeadWithChildren(ctx context.Context, id string) ([]Bead, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetBeadWithChildren.Lock()
	mock.calls.GetBeadWithChildren = append(mock.calls.GetBeadWithChildren, callInfo)
	mock.lockGetBeadWithChildren.Unlock()
	if mock.GetBeadWithChildrenFunc == nil {
		var (
			beadsOut []Bead
			errOut   error
		)
		return beadsOut, errOut
	}
	return mock.GetBeadWithChildrenFunc(ctx, id)
}

// GetBeadWithChildrenCalls gets all the calls that were made to GetBeadWithChildren.
// Check the length with:
//
//	len(mockedReader.GetBeadWithChildrenCalls())
func (mock *BeadsReaderMock) GetBeadWithChildrenCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetBeadWithChildren.RLock()
	calls = mock.calls.GetBeadWithChildren
	mock.lockGetBeadWithChildren.RUnlock()
	return calls
}

// GetBeadsWithDeps calls GetBeadsWithDepsFunc.
func (mock *BeadsReaderMock) GetBeadsWithDeps(ctx context.Context, beadIDs []string) (*BeadsWithDepsResult, error) {
	callInfo := struct {
		Ctx     context.Context
		BeadIDs []string
	}{
		Ctx:     ctx,
		BeadIDs: beadIDs,
	}
	mock.lockGetBeadsWithDeps.Lock()
	mock.calls.GetBeadsWithDeps = append(mock.calls.GetBeadsWithDeps, callInfo)
	mock.lockGetBeadsWithDeps.Unlock()
	if mock.GetBeadsWithDepsFunc == nil {
		var (
			beadsWithDepsResultOut *BeadsWithDepsResult
			errOut                 error
		)
		return beadsWithDepsResultOut, errOut
	}
	return mock.GetBeadsWithDepsFunc(ctx, beadIDs)
}

// GetBeadsWithDepsCalls gets all the calls that were made to GetBeadsWithDeps.
// Check the length with:
//
//	len(mockedReader.GetBeadsWithDepsCalls())
func (mock *BeadsReaderMock) GetBeadsWithDepsCalls() []struct {
	Ctx     context.Context
	BeadIDs []string
} {
	var calls []struct {
		Ctx     context.Context
		BeadIDs []string
	}
	mock.lockGetBeadsWithDeps.RLock()
	calls = mock.calls.GetBeadsWithDeps
	mock.lockGetBeadsWithDeps.RUnlock()
	return calls
}

// GetReadyBeads calls GetReadyBeadsFunc.
func (mock *BeadsReaderMock) GetReadyBeads(ctx context.Context) ([]Bead, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockGetReadyBeads.Lock()
	mock.calls.GetReadyBeads = append(mock.calls.GetReadyBeads, callInfo)
	mock.lockGetReadyBeads.Unlock()
	if mock.GetReadyBeadsFunc == nil {
		var (
			beadsOut []Bead
			errOut   error
		)
		return beadsOut, errOut
	}
	return mock.GetReadyBeadsFunc(ctx)
}

// GetReadyBeadsCalls gets all the calls that were made to GetReadyBeads.
// Check the length with:
//
//	len(mockedReader.GetReadyBeadsCalls())
func (mock *BeadsReaderMock) GetReadyBeadsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockGetReadyBeads.RLock()
	calls = mock.calls.GetReadyBeads
	mock.lockGetReadyBeads.RUnlock()
	return calls
}

// GetTransitiveDependencies calls GetTransitiveDependenciesFunc.
func (mock *BeadsReaderMock) GetTransitiveDependencies(ctx context.Context, id string) ([]Bead, error) {
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetTransitiveDependencies.Lock()
	mock.calls.GetTransitiveDependencies = append(mock.calls.GetTransitiveDependencies, callInfo)
	mock.lockGetTransitiveDependencies.Unlock()
	if mock.GetTransitiveDependenciesFunc == nil {
		var (
			beadsOut []Bead
			errOut   error
		)
		return beadsOut, errOut
	}
	return mock.GetTransitiveDependenciesFunc(ctx, id)
}

// GetTransitiveDependenciesCalls gets all the calls that were made to GetTransitiveDependencies.
// Check the length with:
//
//	len(mockedReader.GetTransitiveDependenciesCalls())
func (mock *BeadsReaderMock) GetTransitiveDependenciesCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetTransitiveDependencies.RLock()
	calls = mock.calls.GetTransitiveDependencies
	mock.lockGetTransitiveDependencies.RUnlock()
	return calls
}

// ListBeads calls ListBeadsFunc.
func (mock *BeadsReaderMock) ListBeads(ctx context.Context, status string) ([]Bead, error) {
	callInfo := struct {
		Ctx    context.Context
		Status string
	}{
		Ctx:    ctx,
		Status: status,
	}
	mock.lockListBeads.Lock()
	mock.calls.ListBeads = append(mock.calls.ListBeads, callInfo)
	mock.lockListBeads.Unlock()
	if mock.ListBeadsFunc == nil {
		var (
			beadsOut []Bead
			errOut   error
		)
		return beadsOut, errOut
	}
	return mock.ListBeadsFunc(ctx, status)
}

// ListBeadsCalls gets all the calls that were made to ListBeads.
// Check the length with:
//
//	len(mockedReader.ListBeadsCalls())
func (mock *BeadsReaderMock) ListBeadsCalls() []struct {
	Ctx    context.Context
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		Status string
	}
	mock.lockListBeads.RLock()
	calls = mock.calls.ListBeads
	mock.lockListBeads.RUnlock()
	return calls
}
