// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testutil

import (
	"context"
	"github.com/newhook/co/internal/zellij"
	"sync"
)

// Ensure, that SessionManagerMock does implement zellij.SessionManager.
// If this is not the case, regenerate this file with moq.
var _ zellij.SessionManager = &SessionManagerMock{}

// SessionManagerMock is a mock implementation of zellij.SessionManager.
//
//	func TestSomethingThatUsesSessionManager(t *testing.T) {
//
//		// make and configure a mocked zellij.SessionManager
//		mockedSessionManager := &SessionManagerMock{
//			CreateSessionFunc: func(ctx context.Context, name string) error {
//				panic("mock out the CreateSession method")
//			},
//			CreateSessionWithLayoutFunc: func(ctx context.Context, name string, projectRoot string) error {
//				panic("mock out the CreateSessionWithLayout method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, name string) error {
//				panic("mock out the DeleteSession method")
//			},
//			EnsureSessionFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the EnsureSession method")
//			},
//			EnsureSessionWithLayoutFunc: func(ctx context.Context, name string, projectRoot string) (bool, error) {
//				panic("mock out the EnsureSessionWithLayout method")
//			},
//			IsSessionActiveFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the IsSessionActive method")
//			},
//			ListSessionsFunc: func(ctx context.Context) ([]string, error) {
//				panic("mock out the ListSessions method")
//			},
//			SessionFunc: func(name string) zellij.Session {
//				panic("mock out the Session method")
//			},
//			SessionExistsFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the SessionExists method")
//			},
//		}
//
//		// use mockedSessionManager in code that requires zellij.SessionManager
//		// and then make assertions.
//
//	}
type SessionManagerMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, name string) error

	// CreateSessionWithLayoutFunc mocks the CreateSessionWithLayout method.
	CreateSessionWithLayoutFunc func(ctx context.Context, name string, projectRoot string) error

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, name string) error

	// EnsureSessionFunc mocks the EnsureSession method.
	EnsureSessionFunc func(ctx context.Context, name string) (bool, error)

	// EnsureSessionWithLayoutFunc mocks the EnsureSessionWithLayout method.
	EnsureSessionWithLayoutFunc func(ctx context.Context, name string, projectRoot string) (bool, error)

	// IsSessionActiveFunc mocks the IsSessionActive method.
	IsSessionActiveFunc func(ctx context.Context, name string) (bool, error)

	// ListSessionsFunc mocks the ListSessions method.
	ListSessionsFunc func(ctx context.Context) ([]string, error)

	// SessionFunc mocks the Session method.
	SessionFunc func(name string) zellij.Session

	// SessionExistsFunc mocks the SessionExists method.
	SessionExistsFunc func(ctx context.Context, name string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// CreateSessionWithLayout holds details about calls to the CreateSessionWithLayout method.
		CreateSessionWithLayout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// ProjectRoot is the projectRoot argument value.
			ProjectRoot string
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// EnsureSession holds details about calls to the EnsureSession method.
		EnsureSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// EnsureSessionWithLayout holds details about calls to the EnsureSessionWithLayout method.
		EnsureSessionWithLayout []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// ProjectRoot is the projectRoot argument value.
			ProjectRoot string
		}
		// IsSessionActive holds details about calls to the IsSessionActive method.
		IsSessionActive []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// ListSessions holds details about calls to the ListSessions method.
		ListSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Session holds details about calls to the Session method.
		Session []struct {
			// Name is the name argument value.
			Name string
		}
		// SessionExists holds details about calls to the SessionExists method.
		SessionExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockCreateSession           sync.RWMutex
	lockCreateSessionWithLayout sync.RWMutex
	lockDeleteSession           sync.RWMutex
	lockEnsureSession           sync.RWMutex
	lockEnsureSessionWithLayout sync.RWMutex
	lockIsSessionActive         sync.RWMutex
	lockListSessions            sync.RWMutex
	lockSession                 sync.RWMutex
	lockSessionExists           sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *SessionManagerMock) CreateSession(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	if mock.CreateSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateSessionFunc(ctx, name)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedSessionManager.CreateSessionCalls())
func (mock *SessionManagerMock) CreateSessionCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// CreateSessionWithLayout calls CreateSessionWithLayoutFunc.
func (mock *SessionManagerMock) CreateSessionWithLayout(ctx context.Context, name string, projectRoot string) error {
	callInfo := struct {
		Ctx         context.Context
		Name        string
		ProjectRoot string
	}{
		Ctx:         ctx,
		Name:        name,
		ProjectRoot: projectRoot,
	}
	mock.lockCreateSessionWithLayout.Lock()
	mock.calls.CreateSessionWithLayout = append(mock.calls.CreateSessionWithLayout, callInfo)
	mock.lockCreateSessionWithLayout.Unlock()
	if mock.CreateSessionWithLayoutFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateSessionWithLayoutFunc(ctx, name, projectRoot)
}

// CreateSessionWithLayoutCalls gets all the calls that were made to CreateSessionWithLayout.
// Check the length with:
//
//	len(mockedSessionManager.CreateSessionWithLayoutCalls())
func (mock *SessionManagerMock) CreateSessionWithLayoutCalls() []struct {
	Ctx         context.Context
	Name        string
	ProjectRoot string
} {
	var calls []struct {
		Ctx         context.Context
		Name        string
		ProjectRoot string
	}
	mock.lockCreateSessionWithLayout.RLock()
	calls = mock.calls.CreateSessionWithLayout
	mock.lockCreateSessionWithLayout.RUnlock()
	return calls
}

// DeleteSession calls DeleteSessionFunc.
func (mock *SessionManagerMock) DeleteSession(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	if mock.DeleteSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteSessionFunc(ctx, name)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedSessionManager.DeleteSessionCalls())
func (mock *SessionManagerMock) DeleteSessionCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// EnsureSession calls EnsureSessionFunc.
func (mock *SessionManagerMock) EnsureSession(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockEnsureSession.Lock()
	mock.calls.EnsureSession = append(mock.calls.EnsureSession, callInfo)
	mock.lockEnsureSession.Unlock()
	if mock.EnsureSessionFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.EnsureSessionFunc(ctx, name)
}

// EnsureSessionCalls gets all the calls that were made to EnsureSession.
// Check the length with:
//
//	len(mockedSessionManager.EnsureSessionCalls())
func (mock *SessionManagerMock) EnsureSessionCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockEnsureSession.RLock()
	calls = mock.calls.EnsureSession
	mock.lockEnsureSession.RUnlock()
	return calls
}

// EnsureSessionWithLayout calls EnsureSessionWithLayoutFunc.
func (mock *SessionManagerMock) EnsureSessionWithLayout(ctx context.Context, name string, projectRoot string) (bool, error) {
	callInfo := struct {
		Ctx         context.Context
		Name        string
		ProjectRoot string
	}{
		Ctx:         ctx,
		Name:        name,
		ProjectRoot: projectRoot,
	}
	mock.lockEnsureSessionWithLayout.Lock()
	mock.calls.EnsureSessionWithLayout = append(mock.calls.EnsureSessionWithLayout, callInfo)
	mock.lockEnsureSessionWithLayout.Unlock()
	if mock.EnsureSessionWithLayoutFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.EnsureSessionWithLayoutFunc(ctx, name, projectRoot)
}

// EnsureSessionWithLayoutCalls gets all the calls that were made to EnsureSessionWithLayout.
// Check the length with:
//
//	len(mockedSessionManager.EnsureSessionWithLayoutCalls())
func (mock *SessionManagerMock) EnsureSessionWithLayoutCalls() []struct {
	Ctx         context.Context
	Name        string
	ProjectRoot string
} {
	var calls []struct {
		Ctx         context.Context
		Name        string
		ProjectRoot string
	}
	mock.lockEnsureSessionWithLayout.RLock()
	calls = mock.calls.EnsureSessionWithLayout
	mock.lockEnsureSessionWithLayout.RUnlock()
	return calls
}

// IsSessionActive calls IsSessionActiveFunc.
func (mock *SessionManagerMock) IsSessionActive(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockIsSessionActive.Lock()
	mock.calls.IsSessionActive = append(mock.calls.IsSessionActive, callInfo)
	mock.lockIsSessionActive.Unlock()
	if mock.IsSessionActiveFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.IsSessionActiveFunc(ctx, name)
}

// IsSessionActiveCalls gets all the calls that were made to IsSessionActive.
// Check the length with:
//
//	len(mockedSessionManager.IsSessionActiveCalls())
func (mock *SessionManagerMock) IsSessionActiveCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockIsSessionActive.RLock()
	calls = mock.calls.IsSessionActive
	mock.lockIsSessionActive.RUnlock()
	return calls
}

// ListSessions calls ListSessionsFunc.
func (mock *SessionManagerMock) ListSessions(ctx context.Context) ([]string, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListSessions.Lock()
	mock.calls.ListSessions = append(mock.calls.ListSessions, callInfo)
	mock.lockListSessions.Unlock()
	if mock.ListSessionsFunc == nil {
		var (
			stringsOut []string
			errOut     error
		)
		return stringsOut, errOut
	}
	return mock.ListSessionsFunc(ctx)
}

// ListSessionsCalls gets all the calls that were made to ListSessions.
// Check the length with:
//
//	len(mockedSessionManager.ListSessionsCalls())
func (mock *SessionManagerMock) ListSessionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListSessions.RLock()
	calls = mock.calls.ListSessions
	mock.lockListSessions.RUnlock()
	return calls
}

// Session calls SessionFunc.
func (mock *SessionManagerMock) Session(name string) zellij.Session {
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockSession.Lock()
	mock.calls.Session = append(mock.calls.Session, callInfo)
	mock.lockSession.Unlock()
	if mock.SessionFunc == nil {
		var (
			sessionOut zellij.Session
		)
		return sessionOut
	}
	return mock.SessionFunc(name)
}

// SessionCalls gets all the calls that were made to Session.
// Check the length with:
//
//	len(mockedSessionManager.SessionCalls())
func (mock *SessionManagerMock) SessionCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockSession.RLock()
	calls = mock.calls.Session
	mock.lockSession.RUnlock()
	return calls
}

// SessionExists calls SessionExistsFunc.
func (mock *SessionManagerMock) SessionExists(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockSessionExists.Lock()
	mock.calls.SessionExists = append(mock.calls.SessionExists, callInfo)
	mock.lockSessionExists.Unlock()
	if mock.SessionExistsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.SessionExistsFunc(ctx, name)
}

// SessionExistsCalls gets all the calls that were made to SessionExists.
// Check the length with:
//
//	len(mockedSessionManager.SessionExistsCalls())
func (mock *SessionManagerMock) SessionExistsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockSessionExists.RLock()
	calls = mock.calls.SessionExists
	mock.lockSessionExists.RUnlock()
	return calls
}

// Ensure, that SessionMock does implement zellij.Session.
// If this is not the case, regenerate this file with moq.
var _ zellij.Session = &SessionMock{}

// SessionMock is a mock implementation of zellij.Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked zellij.Session
//		mockedSession := &SessionMock{
//			ClearAndExecuteFunc: func(ctx context.Context, cmd string) error {
//				panic("mock out the ClearAndExecute method")
//			},
//			CloseTabFunc: func(ctx context.Context) error {
//				panic("mock out the CloseTab method")
//			},
//			CreateTabFunc: func(ctx context.Context, name string, cwd string) error {
//				panic("mock out the CreateTab method")
//			},
//			CreateTabWithCommandFunc: func(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error {
//				panic("mock out the CreateTabWithCommand method")
//			},
//			ExecuteCommandFunc: func(ctx context.Context, cmd string) error {
//				panic("mock out the ExecuteCommand method")
//			},
//			QueryTabNamesFunc: func(ctx context.Context) ([]string, error) {
//				panic("mock out the QueryTabNames method")
//			},
//			RunFunc: func(ctx context.Context, name string, cwd string, command ...string) error {
//				panic("mock out the Run method")
//			},
//			RunFloatingFunc: func(ctx context.Context, name string, cwd string, command ...string) error {
//				panic("mock out the RunFloating method")
//			},
//			SendCtrlCFunc: func(ctx context.Context) error {
//				panic("mock out the SendCtrlC method")
//			},
//			SendEnterFunc: func(ctx context.Context) error {
//				panic("mock out the SendEnter method")
//			},
//			SwitchToTabFunc: func(ctx context.Context, name string) error {
//				panic("mock out the SwitchToTab method")
//			},
//			TabExistsFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the TabExists method")
//			},
//			TerminateAndCloseTabFunc: func(ctx context.Context, tabName string) error {
//				panic("mock out the TerminateAndCloseTab method")
//			},
//			TerminateProcessFunc: func(ctx context.Context) error {
//				panic("mock out the TerminateProcess method")
//			},
//			ToggleFloatingPanesFunc: func(ctx context.Context) error {
//				panic("mock out the ToggleFloatingPanes method")
//			},
//			WriteASCIIFunc: func(ctx context.Context, code int) error {
//				panic("mock out the WriteASCII method")
//			},
//			WriteCharsFunc: func(ctx context.Context, text string) error {
//				panic("mock out the WriteChars method")
//			},
//		}
//
//		// use mockedSession in code that requires zellij.Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// ClearAndExecuteFunc mocks the ClearAndExecute method.
	ClearAndExecuteFunc func(ctx context.Context, cmd string) error

	// CloseTabFunc mocks the CloseTab method.
	CloseTabFunc func(ctx context.Context) error

	// CreateTabFunc mocks the CreateTab method.
	CreateTabFunc func(ctx context.Context, name string, cwd string) error

	// CreateTabWithCommandFunc mocks the CreateTabWithCommand method.
	CreateTabWithCommandFunc func(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error

	// ExecuteCommandFunc mocks the ExecuteCommand method.
	ExecuteCommandFunc func(ctx context.Context, cmd string) error

	// QueryTabNamesFunc mocks the QueryTabNames method.
	QueryTabNamesFunc func(ctx context.Context) ([]string, error)

	// RunFunc mocks the Run method.
	RunFunc func(ctx context.Context, name string, cwd string, command ...string) error

	// RunFloatingFunc mocks the RunFloating method.
	RunFloatingFunc func(ctx context.Context, name string, cwd string, command ...string) error

	// SendCtrlCFunc mocks the SendCtrlC method.
	SendCtrlCFunc func(ctx context.Context) error

	// SendEnterFunc mocks the SendEnter method.
	SendEnterFunc func(ctx context.Context) error

	// SwitchToTabFunc mocks the SwitchToTab method.
	SwitchToTabFunc func(ctx context.Context, name string) error

	// TabExistsFunc mocks the TabExists method.
	TabExistsFunc func(ctx context.Context, name string) (bool, error)

	// TerminateAndCloseTabFunc mocks the TerminateAndCloseTab method.
	TerminateAndCloseTabFunc func(ctx context.Context, tabName string) error

	// TerminateProcessFunc mocks the TerminateProcess method.
	TerminateProcessFunc func(ctx context.Context) error

	// ToggleFloatingPanesFunc mocks the ToggleFloatingPanes method.
	ToggleFloatingPanesFunc func(ctx context.Context) error

	// WriteASCIIFunc mocks the WriteASCII method.
	WriteASCIIFunc func(ctx context.Context, code int) error

	// WriteCharsFunc mocks the WriteChars method.
	WriteCharsFunc func(ctx context.Context, text string) error

	// calls tracks calls to the methods.
	calls struct {
		// ClearAndExecute holds details about calls to the ClearAndExecute method.
		ClearAndExecute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cmd is the cmd argument value.
			Cmd string
		}
		// CloseTab holds details about calls to the CloseTab method.
		CloseTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// CreateTab holds details about calls to the CreateTab method.
		CreateTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Cwd is the cwd argument value.
			Cwd string
		}
		// CreateTabWithCommand holds details about calls to the CreateTabWithCommand method.
		CreateTabWithCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Cwd is the cwd argument value.
			Cwd string
			// Command is the command argument value.
			Command string
			// Args is the args argument value.
			Args []string
			// PaneName is the paneName argument value.
			PaneName string
		}
		// ExecuteCommand holds details about calls to the ExecuteCommand method.
		ExecuteCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cmd is the cmd argument value.
			Cmd string
		}
		// QueryTabNames holds details about calls to the QueryTabNames method.
		QueryTabNames []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Run holds details about calls to the Run method.
		Run []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Cwd is the cwd argument value.
			Cwd string
			// Command is the command argument value.
			Command []string
		}
		// RunFloating holds details about calls to the RunFloating method.
		RunFloating []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Cwd is the cwd argument value.
			Cwd string
			// Command is the command argument value.
			Command []string
		}
		// SendCtrlC holds details about calls to the SendCtrlC method.
		SendCtrlC []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SendEnter holds details about calls to the SendEnter method.
		SendEnter []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SwitchToTab holds details about calls to the SwitchToTab method.
		SwitchToTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// TabExists holds details about calls to the TabExists method.
		TabExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// TerminateAndCloseTab holds details about calls to the TerminateAndCloseTab method.
		TerminateAndCloseTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TabName is the tabName argument value.
			TabName string
		}
		// TerminateProcess holds details about calls to the TerminateProcess method.
		TerminateProcess []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ToggleFloatingPanes holds details about calls to the ToggleFloatingPanes method.
		ToggleFloatingPanes []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// WriteASCII holds details about calls to the WriteASCII method.
		WriteASCII []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Code is the code argument value.
			Code int
		}
		// WriteChars holds details about calls to the WriteChars method.
		WriteChars []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Text is the text argument value.
			Text string
		}
	}
	lockClearAndExecute      sync.RWMutex
	lockCloseTab             sync.RWMutex
	lockCreateTab            sync.RWMutex
	lockCreateTabWithCommand sync.RWMutex
	lockExecuteCommand       sync.RWMutex
	lockQueryTabNames        sync.RWMutex
	lockRun                  sync.RWMutex
	lockRunFloating          sync.RWMutex
	lockSendCtrlC            sync.RWMutex
	lockSendEnter            sync.RWMutex
	lockSwitchToTab          sync.RWMutex
	lockTabExists            sync.RWMutex
	lockTerminateAndCloseTab sync.RWMutex
	lockTerminateProcess     sync.RWMutex
	lockToggleFloatingPanes  sync.RWMutex
	lockWriteASCII           sync.RWMutex
	lockWriteChars           sync.RWMutex
}

// ClearAndExecute calls ClearAndExecuteFunc.
func (mock *SessionMock) ClearAndExecute(ctx context.Context, cmd string) error {
	callInfo := struct {
		Ctx context.Context
		Cmd string
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockClearAndExecute.Lock()
	mock.calls.ClearAndExecute = append(mock.calls.ClearAndExecute, callInfo)
	mock.lockClearAndExecute.Unlock()
	if mock.ClearAndExecuteFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ClearAndExecuteFunc(ctx, cmd)
}

// ClearAndExecuteCalls gets all the calls that were made to ClearAndExecute.
// Check the length with:
//
//	len(mockedSession.ClearAndExecuteCalls())
func (mock *SessionMock) ClearAndExecuteCalls() []struct {
	Ctx context.Context
	Cmd string
} {
	var calls []struct {
		Ctx context.Context
		Cmd string
	}
	mock.lockClearAndExecute.RLock()
	calls = mock.calls.ClearAndExecute
	mock.lockClearAndExecute.RUnlock()
	return calls
}

// CloseTab calls CloseTabFunc.
func (mock *SessionMock) CloseTab(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockCloseTab.Lock()
	mock.calls.CloseTab = append(mock.calls.CloseTab, callInfo)
	mock.lockCloseTab.Unlock()
	if mock.CloseTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloseTabFunc(ctx)
}

// CloseTabCalls gets all the calls that were made to CloseTab.
// Check the length with:
//
//	len(mockedSession.CloseTabCalls())
func (mock *SessionMock) CloseTabCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockCloseTab.RLock()
	calls = mock.calls.CloseTab
	mock.lockCloseTab.RUnlock()
	return calls
}

// CreateTab calls CreateTabFunc.
func (mock *SessionMock) CreateTab(ctx context.Context, name string, cwd string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
		Cwd  string
	}{
		Ctx:  ctx,
		Name: name,
		Cwd:  cwd,
	}
	mock.lockCreateTab.Lock()
	mock.calls.CreateTab = append(mock.calls.CreateTab, callInfo)
	mock.lockCreateTab.Unlock()
	if mock.CreateTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateTabFunc(ctx, name, cwd)
}

// CreateTabCalls gets all the calls that were made to CreateTab.
// Check the length with:
//
//	len(mockedSession.CreateTabCalls())
func (mock *SessionMock) CreateTabCalls() []struct {
	Ctx  context.Context
	Name string
	Cwd  string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
		Cwd  string
	}
	mock.lockCreateTab.RLock()
	calls = mock.calls.CreateTab
	mock.lockCreateTab.RUnlock()
	return calls
}

// CreateTabWithCommand calls CreateTabWithCommandFunc.
func (mock *SessionMock) CreateTabWithCommand(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error {
	callInfo := struct {
		Ctx      context.Context
		Name     string
		Cwd      string
		Command  string
		Args     []string
		PaneName string
	}{
		Ctx:      ctx,
		Name:     name,
		Cwd:      cwd,
		Command:  command,
		Args:     args,
		PaneName: paneName,
	}
	mock.lockCreateTabWithCommand.Lock()
	mock.calls.CreateTabWithCommand = append(mock.calls.CreateTabWithCommand, callInfo)
	mock.lockCreateTabWithCommand.Unlock()
	if mock.CreateTabWithCommandFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateTabWithCommandFunc(ctx, name, cwd, command, args, paneName)
}

// CreateTabWithCommandCalls gets all the calls that were made to CreateTabWithCommand.
// Check the length with:
//
//	len(mockedSession.CreateTabWithCommandCalls())
func (mock *SessionMock) CreateTabWithCommandCalls() []struct {
	Ctx      context.Context
	Name     string
	Cwd      string
	Command  string
	Args     []string
	PaneName string
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		Cwd      string
		Command  string
		Args     []string
		PaneName string
	}
	mock.lockCreateTabWithCommand.RLock()
	calls = mock.calls.CreateTabWithCommand
	mock.lockCreateTabWithCommand.RUnlock()
	return calls
}

// ExecuteCommand calls ExecuteCommandFunc.
func (mock *SessionMock) ExecuteCommand(ctx context.Context, cmd string) error {
	callInfo := struct {
		Ctx context.Context
		Cmd string
	}{
		Ctx: ctx,
		Cmd: cmd,
	}
	mock.lockExecuteCommand.Lock()
	mock.calls.ExecuteCommand = append(mock.calls.ExecuteCommand, callInfo)
	mock.lockExecuteCommand.Unlock()
	if mock.ExecuteCommandFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ExecuteCommandFunc(ctx, cmd)
}

// ExecuteCommandCalls gets all the calls that were made to ExecuteCommand.
// Check the length with:
//
//	len(mockedSession.ExecuteCommandCalls())
func (mock *SessionMock) ExecuteCommandCalls() []struct {
	Ctx context.Context
	Cmd string
} {
	var calls []struct {
		Ctx context.Context
		Cmd string
	}
	mock.lockExecuteCommand.RLock()
	calls = mock.calls.ExecuteCommand
	mock.lockExecuteCommand.RUnlock()
	return calls
}

// QueryTabNames calls QueryTabNamesFunc.
func (mock *SessionMock) QueryTabNames(ctx context.Context) ([]string, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockQueryTabNames.Lock()
	mock.calls.QueryTabNames = append(mock.calls.QueryTabNames, callInfo)
	mock.lockQueryTabNames.Unlock()
	if mock.QueryTabNamesFunc == nil {
		var (
			stringsOut []string
			errOut     error
		)
		return stringsOut, errOut
	}
	return mock.QueryTabNamesFunc(ctx)
}

// QueryTabNamesCalls gets all the calls that were made to QueryTabNames.
// Check the length with:
//
//	len(mockedSession.QueryTabNamesCalls())
func (mock *SessionMock) QueryTabNamesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockQueryTabNames.RLock()
	calls = mock.calls.QueryTabNames
	mock.lockQueryTabNames.RUnlock()
	return calls
}

// Run calls RunFunc.
func (mock *SessionMock) Run(ctx context.Context, name string, cwd string, command ...string) error {
	callInfo := struct {
		Ctx     context.Context
		Name    string
		Cwd     string
		Command []string
	}{
		Ctx:     ctx,
		Name:    name,
		Cwd:     cwd,
		Command: command,
	}
	mock.lockRun.Lock()
	mock.calls.Run = append(mock.calls.Run, callInfo)
	mock.lockRun.Unlock()
	if mock.RunFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RunFunc(ctx, name, cwd, command...)
}

// RunCalls gets all the calls that were made to Run.
// Check the length with:
//
//	len(mockedSession.RunCalls())
func (mock *SessionMock) RunCalls() []struct {
	Ctx     context.Context
	Name    string
	Cwd     string
	Command []string
} {
	var calls []struct {
		Ctx     context.Context
		Name    string
		Cwd     string
		Command []string
	}
	mock.lockRun.RLock()
	calls = mock.calls.Run
	mock.lockRun.RUnlock()
	return calls
}

// RunFloating calls RunFloatingFunc.
func (mock *SessionMock) RunFloating(ctx context.Context, name string, cwd string, command ...string) error {
	callInfo := struct {
		Ctx     context.Context
		Name    string
		Cwd     string
		Command []string
	}{
		Ctx:     ctx,
		Name:    name,
		Cwd:     cwd,
		Command: command,
	}
	mock.lockRunFloating.Lock()
	mock.calls.RunFloating = append(mock.calls.RunFloating, callInfo)
	mock.lockRunFloating.Unlock()
	if mock.RunFloatingFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RunFloatingFunc(ctx, name, cwd, command...)
}

// RunFloatingCalls gets all the calls that were made to RunFloating.
// Check the length with:
//
//	len(mockedSession.RunFloatingCalls())
func (mock *SessionMock) RunFloatingCalls() []struct {
	Ctx     context.Context
	Name    string
	Cwd     string
	Command []string
} {
	var calls []struct {
		Ctx     context.Context
		Name    string
		Cwd     string
		Command []string
	}
	mock.lockRunFloating.RLock()
	calls = mock.calls.RunFloating
	mock.lockRunFloating.RUnlock()
	return calls
}

// SendCtrlC calls SendCtrlCFunc.
func (mock *SessionMock) SendCtrlC(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSendCtrlC.Lock()
	mock.calls.SendCtrlC = append(mock.calls.SendCtrlC, callInfo)
	mock.lockSendCtrlC.Unlock()
	if mock.SendCtrlCFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SendCtrlCFunc(ctx)
}

// SendCtrlCCalls gets all the calls that were made to SendCtrlC.
// Check the length with:
//
//	len(mockedSession.SendCtrlCCalls())
func (mock *SessionMock) SendCtrlCCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSendCtrlC.RLock()
	calls = mock.calls.SendCtrlC
	mock.lockSendCtrlC.RUnlock()
	return calls
}

// SendEnter calls SendEnterFunc.
func (mock *SessionMock) SendEnter(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSendEnter.Lock()
	mock.calls.SendEnter = append(mock.calls.SendEnter, callInfo)
	mock.lockSendEnter.Unlock()
	if mock.SendEnterFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SendEnterFunc(ctx)
}

// SendEnterCalls gets all the calls that were made to SendEnter.
// Check the length with:
//
//	len(mockedSession.SendEnterCalls())
func (mock *SessionMock) SendEnterCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSendEnter.RLock()
	calls = mock.calls.SendEnter
	mock.lockSendEnter.RUnlock()
	return calls
}

// SwitchToTab calls SwitchToTabFunc.
func (mock *SessionMock) SwitchToTab(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockSwitchToTab.Lock()
	mock.calls.SwitchToTab = append(mock.calls.SwitchToTab, callInfo)
	mock.lockSwitchToTab.Unlock()
	if mock.SwitchToTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SwitchToTabFunc(ctx, name)
}

// SwitchToTabCalls gets all the calls that were made to SwitchToTab.
// Check the length with:
//
//	len(mockedSession.SwitchToTabCalls())
func (mock *SessionMock) SwitchToTabCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockSwitchToTab.RLock()
	calls = mock.calls.SwitchToTab
	mock.lockSwitchToTab.RUnlock()
	return calls
}

// TabExists calls TabExistsFunc.
func (mock *SessionMock) TabExists(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockTabExists.Lock()
	mock.calls.TabExists = append(mock.calls.TabExists, callInfo)
	mock.lockTabExists.Unlock()
	if mock.TabExistsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.TabExistsFunc(ctx, name)
}

// TabExistsCalls gets all the calls that were made to TabExists.
// Check the length with:
//
//	len(mockedSession.TabExistsCalls())
func (mock *SessionMock) TabExistsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockTabExists.RLock()
	calls = mock.calls.TabExists
	mock.lockTabExists.RUnlock()
	return calls
}

// TerminateAndCloseTab calls TerminateAndCloseTabFunc.
func (mock *SessionMock) TerminateAndCloseTab(ctx context.Context, tabName string) error {
	callInfo := struct {
		Ctx     context.Context
		TabName string
	}{
		Ctx:     ctx,
		TabName: tabName,
	}
	mock.lockTerminateAndCloseTab.Lock()
	mock.calls.TerminateAndCloseTab = append(mock.calls.TerminateAndCloseTab, callInfo)
	mock.lockTerminateAndCloseTab.Unlock()
	if mock.TerminateAndCloseTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TerminateAndCloseTabFunc(ctx, tabName)
}

// TerminateAndCloseTabCalls gets all the calls that were made to TerminateAndCloseTab.
// Check the length with:
//
//	len(mockedSession.TerminateAndCloseTabCalls())
func (mock *SessionMock) TerminateAndCloseTabCalls() []struct {
	Ctx     context.Context
	TabName string
} {
	var calls []struct {
		Ctx     context.Context
		TabName string
	}
	mock.lockTerminateAndCloseTab.RLock()
	calls = mock.calls.TerminateAndCloseTab
	mock.lockTerminateAndCloseTab.RUnlock()
	return calls
}

// TerminateProcess calls TerminateProcessFunc.
func (mock *SessionMock) TerminateProcess(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockTerminateProcess.Lock()
	mock.calls.TerminateProcess = append(mock.calls.TerminateProcess, callInfo)
	mock.lockTerminateProcess.Unlock()
	if mock.TerminateProcessFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TerminateProcessFunc(ctx)
}

// TerminateProcessCalls gets all the calls that were made to TerminateProcess.
// Check the length with:
//
//	len(mockedSession.TerminateProcessCalls())
func (mock *SessionMock) TerminateProcessCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockTerminateProcess.RLock()
	calls = mock.calls.TerminateProcess
	mock.lockTerminateProcess.RUnlock()
	return calls
}

// ToggleFloatingPanes calls ToggleFloatingPanesFunc.
func (mock *SessionMock) ToggleFloatingPanes(ctx context.Context) error {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockToggleFloatingPanes.Lock()
	mock.calls.ToggleFloatingPanes = append(mock.calls.ToggleFloatingPanes, callInfo)
	mock.lockToggleFloatingPanes.Unlock()
	if mock.ToggleFloatingPanesFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.ToggleFloatingPanesFunc(ctx)
}

// ToggleFloatingPanesCalls gets all the calls that were made to ToggleFloatingPanes.
// Check the length with:
//
//	len(mockedSession.ToggleFloatingPanesCalls())
func (mock *SessionMock) ToggleFloatingPanesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockToggleFloatingPanes.RLock()
	calls = mock.calls.ToggleFloatingPanes
	mock.lockToggleFloatingPanes.RUnlock()
	return calls
}

// WriteASCII calls WriteASCIIFunc.
func (mock *SessionMock) WriteASCII(ctx context.Context, code int) error {
	callInfo := struct {
		Ctx  context.Context
		Code int
	}{
		Ctx:  ctx,
		Code: code,
	}
	mock.lockWriteASCII.Lock()
	mock.calls.WriteASCII = append(mock.calls.WriteASCII, callInfo)
	mock.lockWriteASCII.Unlock()
	if mock.WriteASCIIFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WriteASCIIFunc(ctx, code)
}

// WriteASCIICalls gets all the calls that were made to WriteASCII.
// Check the length with:
//
//	len(mockedSession.WriteASCIICalls())
func (mock *SessionMock) WriteASCIICalls() []struct {
	Ctx  context.Context
	Code int
} {
	var calls []struct {
		Ctx  context.Context
		Code int
	}
	mock.lockWriteASCII.RLock()
	calls = mock.calls.WriteASCII
	mock.lockWriteASCII.RUnlock()
	return calls
}

// WriteChars calls WriteCharsFunc.
func (mock *SessionMock) WriteChars(ctx context.Context, text string) error {
	callInfo := struct {
		Ctx  context.Context
		Text string
	}{
		Ctx:  ctx,
		Text: text,
	}
	mock.lockWriteChars.Lock()
	mock.calls.WriteChars = append(mock.calls.WriteChars, callInfo)
	mock.lockWriteChars.Unlock()
	if mock.WriteCharsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.WriteCharsFunc(ctx, text)
}

// WriteCharsCalls gets all the calls that were made to WriteChars.
// Check the length with:
//
//	len(mockedSession.WriteCharsCalls())
func (mock *SessionMock) WriteCharsCalls() []struct {
	Ctx  context.Context
	Text string
} {
	var calls []struct {
		Ctx  context.Context
		Text string
	}
	mock.lockWriteChars.RLock()
	calls = mock.calls.WriteChars
	mock.lockWriteChars.RUnlock()
	return calls
}
