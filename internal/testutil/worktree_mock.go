// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package testutil

import (
	"context"
	"github.com/newhook/co/internal/worktree"
	"sync"
)

// Ensure, that WorktreeOperationsMock does implement worktree.Operations.
// If this is not the case, regenerate this file with moq.
var _ worktree.Operations = &WorktreeOperationsMock{}

// WorktreeOperationsMock is a mock implementation of worktree.Operations.
//
//	func TestSomethingThatUsesOperations(t *testing.T) {
//
//		// make and configure a mocked worktree.Operations
//		mockedOperations := &WorktreeOperationsMock{
//			CreateFunc: func(ctx context.Context, repoPath string, worktreePath string, branch string, baseBranch string) error {
//				panic("mock out the Create method")
//			},
//			CreateFromExistingFunc: func(ctx context.Context, repoPath string, worktreePath string, branch string) error {
//				panic("mock out the CreateFromExisting method")
//			},
//			ExistsPathFunc: func(worktreePath string) bool {
//				panic("mock out the ExistsPath method")
//			},
//			ListFunc: func(ctx context.Context, repoPath string) ([]worktree.Worktree, error) {
//				panic("mock out the List method")
//			},
//			RemoveForceFunc: func(ctx context.Context, repoPath string, worktreePath string) error {
//				panic("mock out the RemoveForce method")
//			},
//		}
//
//		// use mockedOperations in code that requires worktree.Operations
//		// and then make assertions.
//
//	}
type WorktreeOperationsMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, repoPath string, worktreePath string, branch string, baseBranch string) error

	// CreateFromExistingFunc mocks the CreateFromExisting method.
	CreateFromExistingFunc func(ctx context.Context, repoPath string, worktreePath string, branch string) error

	// ExistsPathFunc mocks the ExistsPath method.
	ExistsPathFunc func(worktreePath string) bool

	// ListFunc mocks the List method.
	ListFunc func(ctx context.Context, repoPath string) ([]worktree.Worktree, error)

	// RemoveForceFunc mocks the RemoveForce method.
	RemoveForceFunc func(ctx context.Context, repoPath string, worktreePath string) error

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// WorktreePath is the worktreePath argument value.
			WorktreePath string
			// Branch is the branch argument value.
			Branch string
			// BaseBranch is the baseBranch argument value.
			BaseBranch string
		}
		// CreateFromExisting holds details about calls to the CreateFromExisting method.
		CreateFromExisting []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// WorktreePath is the worktreePath argument value.
			WorktreePath string
			// Branch is the branch argument value.
			Branch string
		}
		// ExistsPath holds details about calls to the ExistsPath method.
		ExistsPath []struct {
			// WorktreePath is the worktreePath argument value.
			WorktreePath string
		}
		// List holds details about calls to the List method.
		List []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
		}
		// RemoveForce holds details about calls to the RemoveForce method.
		RemoveForce []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// WorktreePath is the worktreePath argument value.
			WorktreePath string
		}
	}
	lockCreate             sync.RWMutex
	lockCreateFromExisting sync.RWMutex
	lockExistsPath         sync.RWMutex
	lockList               sync.RWMutex
	lockRemoveForce        sync.RWMutex
}

// Create calls CreateFunc.
func (mock *WorktreeOperationsMock) Create(ctx context.Context, repoPath string, worktreePath string, branch string, baseBranch string) error {
	callInfo := struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
		Branch       string
		BaseBranch   string
	}{
		Ctx:          ctx,
		RepoPath:     repoPath,
		WorktreePath: worktreePath,
		Branch:       branch,
		BaseBranch:   baseBranch,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	if mock.CreateFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateFunc(ctx, repoPath, worktreePath, branch, baseBranch)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//
//	len(mockedOperations.CreateCalls())
func (mock *WorktreeOperationsMock) CreateCalls() []struct {
	Ctx          context.Context
	RepoPath     string
	WorktreePath string
	Branch       string
	BaseBranch   string
} {
	var calls []struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
		Branch       string
		BaseBranch   string
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// CreateFromExisting calls CreateFromExistingFunc.
func (mock *WorktreeOperationsMock) CreateFromExisting(ctx context.Context, repoPath string, worktreePath string, branch string) error {
	callInfo := struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
		Branch       string
	}{
		Ctx:          ctx,
		RepoPath:     repoPath,
		WorktreePath: worktreePath,
		Branch:       branch,
	}
	mock.lockCreateFromExisting.Lock()
	mock.calls.CreateFromExisting = append(mock.calls.CreateFromExisting, callInfo)
	mock.lockCreateFromExisting.Unlock()
	if mock.CreateFromExistingFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateFromExistingFunc(ctx, repoPath, worktreePath, branch)
}

// CreateFromExistingCalls gets all the calls that were made to CreateFromExisting.
// Check the length with:
//
//	len(mockedOperations.CreateFromExistingCalls())
func (mock *WorktreeOperationsMock) CreateFromExistingCalls() []struct {
	Ctx          context.Context
	RepoPath     string
	WorktreePath string
	Branch       string
} {
	var calls []struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
		Branch       string
	}
	mock.lockCreateFromExisting.RLock()
	calls = mock.calls.CreateFromExisting
	mock.lockCreateFromExisting.RUnlock()
	return calls
}

// ExistsPath calls ExistsPathFunc.
func (mock *WorktreeOperationsMock) ExistsPath(worktreePath string) bool {
	callInfo := struct {
		WorktreePath string
	}{
		WorktreePath: worktreePath,
	}
	mock.lockExistsPath.Lock()
	mock.calls.ExistsPath = append(mock.calls.ExistsPath, callInfo)
	mock.lockExistsPath.Unlock()
	if mock.ExistsPathFunc == nil {
		var (
			bOut bool
		)
		return bOut
	}
	return mock.ExistsPathFunc(worktreePath)
}

// ExistsPathCalls gets all the calls that were made to ExistsPath.
// Check the length with:
//
//	len(mockedOperations.ExistsPathCalls())
func (mock *WorktreeOperationsMock) ExistsPathCalls() []struct {
	WorktreePath string
} {
	var calls []struct {
		WorktreePath string
	}
	mock.lockExistsPath.RLock()
	calls = mock.calls.ExistsPath
	mock.lockExistsPath.RUnlock()
	return calls
}

// List calls ListFunc.
func (mock *WorktreeOperationsMock) List(ctx context.Context, repoPath string) ([]worktree.Worktree, error) {
	callInfo := struct {
		Ctx      context.Context
		RepoPath string
	}{
		Ctx:      ctx,
		RepoPath: repoPath,
	}
	mock.lockList.Lock()
	mock.calls.List = append(mock.calls.List, callInfo)
	mock.lockList.Unlock()
	if mock.ListFunc == nil {
		var (
			worktreesOut []worktree.Worktree
			errOut       error
		)
		return worktreesOut, errOut
	}
	return mock.ListFunc(ctx, repoPath)
}

// ListCalls gets all the calls that were made to List.
// Check the length with:
//
//	len(mockedOperations.ListCalls())
func (mock *WorktreeOperationsMock) ListCalls() []struct {
	Ctx      context.Context
	RepoPath string
} {
	var calls []struct {
		Ctx      context.Context
		RepoPath string
	}
	mock.lockList.RLock()
	calls = mock.calls.List
	mock.lockList.RUnlock()
	return calls
}

// RemoveForce calls RemoveForceFunc.
func (mock *WorktreeOperationsMock) RemoveForce(ctx context.Context, repoPath string, worktreePath string) error {
	callInfo := struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
	}{
		Ctx:          ctx,
		RepoPath:     repoPath,
		WorktreePath: worktreePath,
	}
	mock.lockRemoveForce.Lock()
	mock.calls.RemoveForce = append(mock.calls.RemoveForce, callInfo)
	mock.lockRemoveForce.Unlock()
	if mock.RemoveForceFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RemoveForceFunc(ctx, repoPath, worktreePath)
}

// RemoveForceCalls gets all the calls that were made to RemoveForce.
// Check the length with:
//
//	len(mockedOperations.RemoveForceCalls())
func (mock *WorktreeOperationsMock) RemoveForceCalls() []struct {
	Ctx          context.Context
	RepoPath     string
	WorktreePath string
} {
	var calls []struct {
		Ctx          context.Context
		RepoPath     string
		WorktreePath string
	}
	mock.lockRemoveForce.RLock()
	calls = mock.calls.RemoveForce
	mock.lockRemoveForce.RUnlock()
	return calls
}
