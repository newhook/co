// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mise

import (
	"io"
	"sync"
)

// Ensure, that MiseOperationsMock does implement Operations.
// If this is not the case, regenerate this file with moq.
var _ Operations = &MiseOperationsMock{}

// MiseOperationsMock is a mock implementation of Operations.
//
//	func TestSomethingThatUsesOperations(t *testing.T) {
//
//		// make and configure a mocked Operations
//		mockedOperations := &MiseOperationsMock{
//			ExecFunc: func(command string, args ...string) ([]byte, error) {
//				panic("mock out the Exec method")
//			},
//			HasTaskFunc: func(taskName string) bool {
//				panic("mock out the HasTask method")
//			},
//			InitializeFunc: func() error {
//				panic("mock out the Initialize method")
//			},
//			InitializeWithOutputFunc: func(w io.Writer) error {
//				panic("mock out the InitializeWithOutput method")
//			},
//			InstallFunc: func() error {
//				panic("mock out the Install method")
//			},
//			IsManagedFunc: func() bool {
//				panic("mock out the IsManaged method")
//			},
//			RunTaskFunc: func(taskName string) error {
//				panic("mock out the RunTask method")
//			},
//			TrustFunc: func() error {
//				panic("mock out the Trust method")
//			},
//		}
//
//		// use mockedOperations in code that requires Operations
//		// and then make assertions.
//
//	}
type MiseOperationsMock struct {
	// ExecFunc mocks the Exec method.
	ExecFunc func(command string, args ...string) ([]byte, error)

	// HasTaskFunc mocks the HasTask method.
	HasTaskFunc func(taskName string) bool

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func() error

	// InitializeWithOutputFunc mocks the InitializeWithOutput method.
	InitializeWithOutputFunc func(w io.Writer) error

	// InstallFunc mocks the Install method.
	InstallFunc func() error

	// IsManagedFunc mocks the IsManaged method.
	IsManagedFunc func() bool

	// RunTaskFunc mocks the RunTask method.
	RunTaskFunc func(taskName string) error

	// TrustFunc mocks the Trust method.
	TrustFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// Command is the command argument value.
			Command string
			// Args is the args argument value.
			Args []string
		}
		// HasTask holds details about calls to the HasTask method.
		HasTask []struct {
			// TaskName is the taskName argument value.
			TaskName string
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
		}
		// InitializeWithOutput holds details about calls to the InitializeWithOutput method.
		InitializeWithOutput []struct {
			// W is the w argument value.
			W io.Writer
		}
		// Install holds details about calls to the Install method.
		Install []struct {
		}
		// IsManaged holds details about calls to the IsManaged method.
		IsManaged []struct {
		}
		// RunTask holds details about calls to the RunTask method.
		RunTask []struct {
			// TaskName is the taskName argument value.
			TaskName string
		}
		// Trust holds details about calls to the Trust method.
		Trust []struct {
		}
	}
	lockExec                 sync.RWMutex
	lockHasTask              sync.RWMutex
	lockInitialize           sync.RWMutex
	lockInitializeWithOutput sync.RWMutex
	lockInstall              sync.RWMutex
	lockIsManaged            sync.RWMutex
	lockRunTask              sync.RWMutex
	lockTrust                sync.RWMutex
}

// Exec calls ExecFunc.
func (mock *MiseOperationsMock) Exec(command string, args ...string) ([]byte, error) {
	callInfo := struct {
		Command string
		Args    []string
	}{
		Command: command,
		Args:    args,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	if mock.ExecFunc == nil {
		var (
			bytesOut []byte
			errOut   error
		)
		return bytesOut, errOut
	}
	return mock.ExecFunc(command, args...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedOperations.ExecCalls())
func (mock *MiseOperationsMock) ExecCalls() []struct {
	Command string
	Args    []string
} {
	var calls []struct {
		Command string
		Args    []string
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// HasTask calls HasTaskFunc.
func (mock *MiseOperationsMock) HasTask(taskName string) bool {
	callInfo := struct {
		TaskName string
	}{
		TaskName: taskName,
	}
	mock.lockHasTask.Lock()
	mock.calls.HasTask = append(mock.calls.HasTask, callInfo)
	mock.lockHasTask.Unlock()
	if mock.HasTaskFunc == nil {
		var (
			bOut bool
		)
		return bOut
	}
	return mock.HasTaskFunc(taskName)
}

// HasTaskCalls gets all the calls that were made to HasTask.
// Check the length with:
//
//	len(mockedOperations.HasTaskCalls())
func (mock *MiseOperationsMock) HasTaskCalls() []struct {
	TaskName string
} {
	var calls []struct {
		TaskName string
	}
	mock.lockHasTask.RLock()
	calls = mock.calls.HasTask
	mock.lockHasTask.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *MiseOperationsMock) Initialize() error {
	callInfo := struct {
	}{}
	mock.lockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	mock.lockInitialize.Unlock()
	if mock.InitializeFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.InitializeFunc()
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//
//	len(mockedOperations.InitializeCalls())
func (mock *MiseOperationsMock) InitializeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInitialize.RLock()
	calls = mock.calls.Initialize
	mock.lockInitialize.RUnlock()
	return calls
}

// InitializeWithOutput calls InitializeWithOutputFunc.
func (mock *MiseOperationsMock) InitializeWithOutput(w io.Writer) error {
	callInfo := struct {
		W io.Writer
	}{
		W: w,
	}
	mock.lockInitializeWithOutput.Lock()
	mock.calls.InitializeWithOutput = append(mock.calls.InitializeWithOutput, callInfo)
	mock.lockInitializeWithOutput.Unlock()
	if mock.InitializeWithOutputFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.InitializeWithOutputFunc(w)
}

// InitializeWithOutputCalls gets all the calls that were made to InitializeWithOutput.
// Check the length with:
//
//	len(mockedOperations.InitializeWithOutputCalls())
func (mock *MiseOperationsMock) InitializeWithOutputCalls() []struct {
	W io.Writer
} {
	var calls []struct {
		W io.Writer
	}
	mock.lockInitializeWithOutput.RLock()
	calls = mock.calls.InitializeWithOutput
	mock.lockInitializeWithOutput.RUnlock()
	return calls
}

// Install calls InstallFunc.
func (mock *MiseOperationsMock) Install() error {
	callInfo := struct {
	}{}
	mock.lockInstall.Lock()
	mock.calls.Install = append(mock.calls.Install, callInfo)
	mock.lockInstall.Unlock()
	if mock.InstallFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.InstallFunc()
}

// InstallCalls gets all the calls that were made to Install.
// Check the length with:
//
//	len(mockedOperations.InstallCalls())
func (mock *MiseOperationsMock) InstallCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInstall.RLock()
	calls = mock.calls.Install
	mock.lockInstall.RUnlock()
	return calls
}

// IsManaged calls IsManagedFunc.
func (mock *MiseOperationsMock) IsManaged() bool {
	callInfo := struct {
	}{}
	mock.lockIsManaged.Lock()
	mock.calls.IsManaged = append(mock.calls.IsManaged, callInfo)
	mock.lockIsManaged.Unlock()
	if mock.IsManagedFunc == nil {
		var (
			bOut bool
		)
		return bOut
	}
	return mock.IsManagedFunc()
}

// IsManagedCalls gets all the calls that were made to IsManaged.
// Check the length with:
//
//	len(mockedOperations.IsManagedCalls())
func (mock *MiseOperationsMock) IsManagedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsManaged.RLock()
	calls = mock.calls.IsManaged
	mock.lockIsManaged.RUnlock()
	return calls
}

// RunTask calls RunTaskFunc.
func (mock *MiseOperationsMock) RunTask(taskName string) error {
	callInfo := struct {
		TaskName string
	}{
		TaskName: taskName,
	}
	mock.lockRunTask.Lock()
	mock.calls.RunTask = append(mock.calls.RunTask, callInfo)
	mock.lockRunTask.Unlock()
	if mock.RunTaskFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.RunTaskFunc(taskName)
}

// RunTaskCalls gets all the calls that were made to RunTask.
// Check the length with:
//
//	len(mockedOperations.RunTaskCalls())
func (mock *MiseOperationsMock) RunTaskCalls() []struct {
	TaskName string
} {
	var calls []struct {
		TaskName string
	}
	mock.lockRunTask.RLock()
	calls = mock.calls.RunTask
	mock.lockRunTask.RUnlock()
	return calls
}

// Trust calls TrustFunc.
func (mock *MiseOperationsMock) Trust() error {
	callInfo := struct {
	}{}
	mock.lockTrust.Lock()
	mock.calls.Trust = append(mock.calls.Trust, callInfo)
	mock.lockTrust.Unlock()
	if mock.TrustFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TrustFunc()
}

// TrustCalls gets all the calls that were made to Trust.
// Check the length with:
//
//	len(mockedOperations.TrustCalls())
func (mock *MiseOperationsMock) TrustCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTrust.RLock()
	calls = mock.calls.Trust
	mock.lockTrust.RUnlock()
	return calls
}
