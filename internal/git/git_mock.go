// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package git

import (
	"context"
	"sync"
)

// Ensure, that GitOperationsMock does implement Operations.
// If this is not the case, regenerate this file with moq.
var _ Operations = &GitOperationsMock{}

// GitOperationsMock is a mock implementation of Operations.
//
//	func TestSomethingThatUsesOperations(t *testing.T) {
//
//		// make and configure a mocked Operations
//		mockedOperations := &GitOperationsMock{
//			BranchExistsFunc: func(ctx context.Context, repoPath string, branchName string) bool {
//				panic("mock out the BranchExists method")
//			},
//			CloneFunc: func(ctx context.Context, source string, dest string) error {
//				panic("mock out the Clone method")
//			},
//			FetchBranchFunc: func(ctx context.Context, repoPath string, branch string) error {
//				panic("mock out the FetchBranch method")
//			},
//			FetchPRRefFunc: func(ctx context.Context, repoPath string, prNumber int, localBranch string) error {
//				panic("mock out the FetchPRRef method")
//			},
//			ListBranchesFunc: func(ctx context.Context, repoPath string) ([]string, error) {
//				panic("mock out the ListBranches method")
//			},
//			PullFunc: func(ctx context.Context, dir string) error {
//				panic("mock out the Pull method")
//			},
//			PushSetUpstreamFunc: func(ctx context.Context, branch string, dir string) error {
//				panic("mock out the PushSetUpstream method")
//			},
//			ValidateExistingBranchFunc: func(ctx context.Context, repoPath string, branchName string) (bool, bool, error) {
//				panic("mock out the ValidateExistingBranch method")
//			},
//		}
//
//		// use mockedOperations in code that requires Operations
//		// and then make assertions.
//
//	}
type GitOperationsMock struct {
	// BranchExistsFunc mocks the BranchExists method.
	BranchExistsFunc func(ctx context.Context, repoPath string, branchName string) bool

	// CloneFunc mocks the Clone method.
	CloneFunc func(ctx context.Context, source string, dest string) error

	// FetchBranchFunc mocks the FetchBranch method.
	FetchBranchFunc func(ctx context.Context, repoPath string, branch string) error

	// FetchPRRefFunc mocks the FetchPRRef method.
	FetchPRRefFunc func(ctx context.Context, repoPath string, prNumber int, localBranch string) error

	// ListBranchesFunc mocks the ListBranches method.
	ListBranchesFunc func(ctx context.Context, repoPath string) ([]string, error)

	// PullFunc mocks the Pull method.
	PullFunc func(ctx context.Context, dir string) error

	// PushSetUpstreamFunc mocks the PushSetUpstream method.
	PushSetUpstreamFunc func(ctx context.Context, branch string, dir string) error

	// ValidateExistingBranchFunc mocks the ValidateExistingBranch method.
	ValidateExistingBranchFunc func(ctx context.Context, repoPath string, branchName string) (bool, bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// BranchExists holds details about calls to the BranchExists method.
		BranchExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// BranchName is the branchName argument value.
			BranchName string
		}
		// Clone holds details about calls to the Clone method.
		Clone []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Source is the source argument value.
			Source string
			// Dest is the dest argument value.
			Dest string
		}
		// FetchBranch holds details about calls to the FetchBranch method.
		FetchBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// Branch is the branch argument value.
			Branch string
		}
		// FetchPRRef holds details about calls to the FetchPRRef method.
		FetchPRRef []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// PrNumber is the prNumber argument value.
			PrNumber int
			// LocalBranch is the localBranch argument value.
			LocalBranch string
		}
		// ListBranches holds details about calls to the ListBranches method.
		ListBranches []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
		}
		// Pull holds details about calls to the Pull method.
		Pull []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Dir is the dir argument value.
			Dir string
		}
		// PushSetUpstream holds details about calls to the PushSetUpstream method.
		PushSetUpstream []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Branch is the branch argument value.
			Branch string
			// Dir is the dir argument value.
			Dir string
		}
		// ValidateExistingBranch holds details about calls to the ValidateExistingBranch method.
		ValidateExistingBranch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// RepoPath is the repoPath argument value.
			RepoPath string
			// BranchName is the branchName argument value.
			BranchName string
		}
	}
	lockBranchExists           sync.RWMutex
	lockClone                  sync.RWMutex
	lockFetchBranch            sync.RWMutex
	lockFetchPRRef             sync.RWMutex
	lockListBranches           sync.RWMutex
	lockPull                   sync.RWMutex
	lockPushSetUpstream        sync.RWMutex
	lockValidateExistingBranch sync.RWMutex
}

// BranchExists calls BranchExistsFunc.
func (mock *GitOperationsMock) BranchExists(ctx context.Context, repoPath string, branchName string) bool {
	callInfo := struct {
		Ctx        context.Context
		RepoPath   string
		BranchName string
	}{
		Ctx:        ctx,
		RepoPath:   repoPath,
		BranchName: branchName,
	}
	mock.lockBranchExists.Lock()
	mock.calls.BranchExists = append(mock.calls.BranchExists, callInfo)
	mock.lockBranchExists.Unlock()
	if mock.BranchExistsFunc == nil {
		var (
			bOut bool
		)
		return bOut
	}
	return mock.BranchExistsFunc(ctx, repoPath, branchName)
}

// BranchExistsCalls gets all the calls that were made to BranchExists.
// Check the length with:
//
//	len(mockedOperations.BranchExistsCalls())
func (mock *GitOperationsMock) BranchExistsCalls() []struct {
	Ctx        context.Context
	RepoPath   string
	BranchName string
} {
	var calls []struct {
		Ctx        context.Context
		RepoPath   string
		BranchName string
	}
	mock.lockBranchExists.RLock()
	calls = mock.calls.BranchExists
	mock.lockBranchExists.RUnlock()
	return calls
}

// Clone calls CloneFunc.
func (mock *GitOperationsMock) Clone(ctx context.Context, source string, dest string) error {
	callInfo := struct {
		Ctx    context.Context
		Source string
		Dest   string
	}{
		Ctx:    ctx,
		Source: source,
		Dest:   dest,
	}
	mock.lockClone.Lock()
	mock.calls.Clone = append(mock.calls.Clone, callInfo)
	mock.lockClone.Unlock()
	if mock.CloneFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CloneFunc(ctx, source, dest)
}

// CloneCalls gets all the calls that were made to Clone.
// Check the length with:
//
//	len(mockedOperations.CloneCalls())
func (mock *GitOperationsMock) CloneCalls() []struct {
	Ctx    context.Context
	Source string
	Dest   string
} {
	var calls []struct {
		Ctx    context.Context
		Source string
		Dest   string
	}
	mock.lockClone.RLock()
	calls = mock.calls.Clone
	mock.lockClone.RUnlock()
	return calls
}

// FetchBranch calls FetchBranchFunc.
func (mock *GitOperationsMock) FetchBranch(ctx context.Context, repoPath string, branch string) error {
	callInfo := struct {
		Ctx      context.Context
		RepoPath string
		Branch   string
	}{
		Ctx:      ctx,
		RepoPath: repoPath,
		Branch:   branch,
	}
	mock.lockFetchBranch.Lock()
	mock.calls.FetchBranch = append(mock.calls.FetchBranch, callInfo)
	mock.lockFetchBranch.Unlock()
	if mock.FetchBranchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.FetchBranchFunc(ctx, repoPath, branch)
}

// FetchBranchCalls gets all the calls that were made to FetchBranch.
// Check the length with:
//
//	len(mockedOperations.FetchBranchCalls())
func (mock *GitOperationsMock) FetchBranchCalls() []struct {
	Ctx      context.Context
	RepoPath string
	Branch   string
} {
	var calls []struct {
		Ctx      context.Context
		RepoPath string
		Branch   string
	}
	mock.lockFetchBranch.RLock()
	calls = mock.calls.FetchBranch
	mock.lockFetchBranch.RUnlock()
	return calls
}

// FetchPRRef calls FetchPRRefFunc.
func (mock *GitOperationsMock) FetchPRRef(ctx context.Context, repoPath string, prNumber int, localBranch string) error {
	callInfo := struct {
		Ctx         context.Context
		RepoPath    string
		PrNumber    int
		LocalBranch string
	}{
		Ctx:         ctx,
		RepoPath:    repoPath,
		PrNumber:    prNumber,
		LocalBranch: localBranch,
	}
	mock.lockFetchPRRef.Lock()
	mock.calls.FetchPRRef = append(mock.calls.FetchPRRef, callInfo)
	mock.lockFetchPRRef.Unlock()
	if mock.FetchPRRefFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.FetchPRRefFunc(ctx, repoPath, prNumber, localBranch)
}

// FetchPRRefCalls gets all the calls that were made to FetchPRRef.
// Check the length with:
//
//	len(mockedOperations.FetchPRRefCalls())
func (mock *GitOperationsMock) FetchPRRefCalls() []struct {
	Ctx         context.Context
	RepoPath    string
	PrNumber    int
	LocalBranch string
} {
	var calls []struct {
		Ctx         context.Context
		RepoPath    string
		PrNumber    int
		LocalBranch string
	}
	mock.lockFetchPRRef.RLock()
	calls = mock.calls.FetchPRRef
	mock.lockFetchPRRef.RUnlock()
	return calls
}

// ListBranches calls ListBranchesFunc.
func (mock *GitOperationsMock) ListBranches(ctx context.Context, repoPath string) ([]string, error) {
	callInfo := struct {
		Ctx      context.Context
		RepoPath string
	}{
		Ctx:      ctx,
		RepoPath: repoPath,
	}
	mock.lockListBranches.Lock()
	mock.calls.ListBranches = append(mock.calls.ListBranches, callInfo)
	mock.lockListBranches.Unlock()
	if mock.ListBranchesFunc == nil {
		var (
			stringsOut []string
			errOut     error
		)
		return stringsOut, errOut
	}
	return mock.ListBranchesFunc(ctx, repoPath)
}

// ListBranchesCalls gets all the calls that were made to ListBranches.
// Check the length with:
//
//	len(mockedOperations.ListBranchesCalls())
func (mock *GitOperationsMock) ListBranchesCalls() []struct {
	Ctx      context.Context
	RepoPath string
} {
	var calls []struct {
		Ctx      context.Context
		RepoPath string
	}
	mock.lockListBranches.RLock()
	calls = mock.calls.ListBranches
	mock.lockListBranches.RUnlock()
	return calls
}

// Pull calls PullFunc.
func (mock *GitOperationsMock) Pull(ctx context.Context, dir string) error {
	callInfo := struct {
		Ctx context.Context
		Dir string
	}{
		Ctx: ctx,
		Dir: dir,
	}
	mock.lockPull.Lock()
	mock.calls.Pull = append(mock.calls.Pull, callInfo)
	mock.lockPull.Unlock()
	if mock.PullFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PullFunc(ctx, dir)
}

// PullCalls gets all the calls that were made to Pull.
// Check the length with:
//
//	len(mockedOperations.PullCalls())
func (mock *GitOperationsMock) PullCalls() []struct {
	Ctx context.Context
	Dir string
} {
	var calls []struct {
		Ctx context.Context
		Dir string
	}
	mock.lockPull.RLock()
	calls = mock.calls.Pull
	mock.lockPull.RUnlock()
	return calls
}

// PushSetUpstream calls PushSetUpstreamFunc.
func (mock *GitOperationsMock) PushSetUpstream(ctx context.Context, branch string, dir string) error {
	callInfo := struct {
		Ctx    context.Context
		Branch string
		Dir    string
	}{
		Ctx:    ctx,
		Branch: branch,
		Dir:    dir,
	}
	mock.lockPushSetUpstream.Lock()
	mock.calls.PushSetUpstream = append(mock.calls.PushSetUpstream, callInfo)
	mock.lockPushSetUpstream.Unlock()
	if mock.PushSetUpstreamFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.PushSetUpstreamFunc(ctx, branch, dir)
}

// PushSetUpstreamCalls gets all the calls that were made to PushSetUpstream.
// Check the length with:
//
//	len(mockedOperations.PushSetUpstreamCalls())
func (mock *GitOperationsMock) PushSetUpstreamCalls() []struct {
	Ctx    context.Context
	Branch string
	Dir    string
} {
	var calls []struct {
		Ctx    context.Context
		Branch string
		Dir    string
	}
	mock.lockPushSetUpstream.RLock()
	calls = mock.calls.PushSetUpstream
	mock.lockPushSetUpstream.RUnlock()
	return calls
}

// ValidateExistingBranch calls ValidateExistingBranchFunc.
func (mock *GitOperationsMock) ValidateExistingBranch(ctx context.Context, repoPath string, branchName string) (bool, bool, error) {
	callInfo := struct {
		Ctx        context.Context
		RepoPath   string
		BranchName string
	}{
		Ctx:        ctx,
		RepoPath:   repoPath,
		BranchName: branchName,
	}
	mock.lockValidateExistingBranch.Lock()
	mock.calls.ValidateExistingBranch = append(mock.calls.ValidateExistingBranch, callInfo)
	mock.lockValidateExistingBranch.Unlock()
	if mock.ValidateExistingBranchFunc == nil {
		var (
			existsLocalOut  bool
			existsRemoteOut bool
			errOut          error
		)
		return existsLocalOut, existsRemoteOut, errOut
	}
	return mock.ValidateExistingBranchFunc(ctx, repoPath, branchName)
}

// ValidateExistingBranchCalls gets all the calls that were made to ValidateExistingBranch.
// Check the length with:
//
//	len(mockedOperations.ValidateExistingBranchCalls())
func (mock *GitOperationsMock) ValidateExistingBranchCalls() []struct {
	Ctx        context.Context
	RepoPath   string
	BranchName string
} {
	var calls []struct {
		Ctx        context.Context
		RepoPath   string
		BranchName string
	}
	mock.lockValidateExistingBranch.RLock()
	calls = mock.calls.ValidateExistingBranch
	mock.lockValidateExistingBranch.RUnlock()
	return calls
}
