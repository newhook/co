// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package work

import (
	"context"
	"github.com/newhook/co/internal/project"
	"io"
	"sync"
)

// Ensure, that OrchestratorManagerMock does implement OrchestratorManager.
// If this is not the case, regenerate this file with moq.
var _ OrchestratorManager = &OrchestratorManagerMock{}

// OrchestratorManagerMock is a mock implementation of OrchestratorManager.
//
//	func TestSomethingThatUsesOrchestratorManager(t *testing.T) {
//
//		// make and configure a mocked OrchestratorManager
//		mockedOrchestratorManager := &OrchestratorManagerMock{
//			EnsureWorkOrchestratorFunc: func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) (bool, error) {
//				panic("mock out the EnsureWorkOrchestrator method")
//			},
//			OpenClaudeSessionFunc: func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, cfg *project.Config, w io.Writer) error {
//				panic("mock out the OpenClaudeSession method")
//			},
//			OpenConsoleFunc: func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, w io.Writer) error {
//				panic("mock out the OpenConsole method")
//			},
//			SpawnPlanSessionFunc: func(ctx context.Context, beadID string, projName string, mainRepoPath string, w io.Writer) error {
//				panic("mock out the SpawnPlanSession method")
//			},
//			SpawnWorkOrchestratorFunc: func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) error {
//				panic("mock out the SpawnWorkOrchestrator method")
//			},
//			TerminateWorkTabsFunc: func(ctx context.Context, workID string, projName string, w io.Writer) error {
//				panic("mock out the TerminateWorkTabs method")
//			},
//		}
//
//		// use mockedOrchestratorManager in code that requires OrchestratorManager
//		// and then make assertions.
//
//	}
type OrchestratorManagerMock struct {
	// EnsureWorkOrchestratorFunc mocks the EnsureWorkOrchestrator method.
	EnsureWorkOrchestratorFunc func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) (bool, error)

	// OpenClaudeSessionFunc mocks the OpenClaudeSession method.
	OpenClaudeSessionFunc func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, cfg *project.Config, w io.Writer) error

	// OpenConsoleFunc mocks the OpenConsole method.
	OpenConsoleFunc func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, w io.Writer) error

	// SpawnPlanSessionFunc mocks the SpawnPlanSession method.
	SpawnPlanSessionFunc func(ctx context.Context, beadID string, projName string, mainRepoPath string, w io.Writer) error

	// SpawnWorkOrchestratorFunc mocks the SpawnWorkOrchestrator method.
	SpawnWorkOrchestratorFunc func(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) error

	// TerminateWorkTabsFunc mocks the TerminateWorkTabs method.
	TerminateWorkTabsFunc func(ctx context.Context, workID string, projName string, w io.Writer) error

	// calls tracks calls to the methods.
	calls struct {
		// EnsureWorkOrchestrator holds details about calls to the EnsureWorkOrchestrator method.
		EnsureWorkOrchestrator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjName is the projName argument value.
			ProjName string
			// WorkDir is the workDir argument value.
			WorkDir string
			// FriendlyName is the friendlyName argument value.
			FriendlyName string
			// W is the w argument value.
			W io.Writer
		}
		// OpenClaudeSession holds details about calls to the OpenClaudeSession method.
		OpenClaudeSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjName is the projName argument value.
			ProjName string
			// WorkDir is the workDir argument value.
			WorkDir string
			// FriendlyName is the friendlyName argument value.
			FriendlyName string
			// HooksEnv is the hooksEnv argument value.
			HooksEnv []string
			// Cfg is the cfg argument value.
			Cfg *project.Config
			// W is the w argument value.
			W io.Writer
		}
		// OpenConsole holds details about calls to the OpenConsole method.
		OpenConsole []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjName is the projName argument value.
			ProjName string
			// WorkDir is the workDir argument value.
			WorkDir string
			// FriendlyName is the friendlyName argument value.
			FriendlyName string
			// HooksEnv is the hooksEnv argument value.
			HooksEnv []string
			// W is the w argument value.
			W io.Writer
		}
		// SpawnPlanSession holds details about calls to the SpawnPlanSession method.
		SpawnPlanSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// BeadID is the beadID argument value.
			BeadID string
			// ProjName is the projName argument value.
			ProjName string
			// MainRepoPath is the mainRepoPath argument value.
			MainRepoPath string
			// W is the w argument value.
			W io.Writer
		}
		// SpawnWorkOrchestrator holds details about calls to the SpawnWorkOrchestrator method.
		SpawnWorkOrchestrator []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjName is the projName argument value.
			ProjName string
			// WorkDir is the workDir argument value.
			WorkDir string
			// FriendlyName is the friendlyName argument value.
			FriendlyName string
			// W is the w argument value.
			W io.Writer
		}
		// TerminateWorkTabs holds details about calls to the TerminateWorkTabs method.
		TerminateWorkTabs []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// WorkID is the workID argument value.
			WorkID string
			// ProjName is the projName argument value.
			ProjName string
			// W is the w argument value.
			W io.Writer
		}
	}
	lockEnsureWorkOrchestrator sync.RWMutex
	lockOpenClaudeSession      sync.RWMutex
	lockOpenConsole            sync.RWMutex
	lockSpawnPlanSession       sync.RWMutex
	lockSpawnWorkOrchestrator  sync.RWMutex
	lockTerminateWorkTabs      sync.RWMutex
}

// EnsureWorkOrchestrator calls EnsureWorkOrchestratorFunc.
func (mock *OrchestratorManagerMock) EnsureWorkOrchestrator(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) (bool, error) {
	callInfo := struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}{
		Ctx:          ctx,
		WorkID:       workID,
		ProjName:     projName,
		WorkDir:      workDir,
		FriendlyName: friendlyName,
		W:            w,
	}
	mock.lockEnsureWorkOrchestrator.Lock()
	mock.calls.EnsureWorkOrchestrator = append(mock.calls.EnsureWorkOrchestrator, callInfo)
	mock.lockEnsureWorkOrchestrator.Unlock()
	if mock.EnsureWorkOrchestratorFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.EnsureWorkOrchestratorFunc(ctx, workID, projName, workDir, friendlyName, w)
}

// EnsureWorkOrchestratorCalls gets all the calls that were made to EnsureWorkOrchestrator.
// Check the length with:
//
//	len(mockedOrchestratorManager.EnsureWorkOrchestratorCalls())
func (mock *OrchestratorManagerMock) EnsureWorkOrchestratorCalls() []struct {
	Ctx          context.Context
	WorkID       string
	ProjName     string
	WorkDir      string
	FriendlyName string
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}
	mock.lockEnsureWorkOrchestrator.RLock()
	calls = mock.calls.EnsureWorkOrchestrator
	mock.lockEnsureWorkOrchestrator.RUnlock()
	return calls
}

// OpenClaudeSession calls OpenClaudeSessionFunc.
func (mock *OrchestratorManagerMock) OpenClaudeSession(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, cfg *project.Config, w io.Writer) error {
	callInfo := struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		HooksEnv     []string
		Cfg          *project.Config
		W            io.Writer
	}{
		Ctx:          ctx,
		WorkID:       workID,
		ProjName:     projName,
		WorkDir:      workDir,
		FriendlyName: friendlyName,
		HooksEnv:     hooksEnv,
		Cfg:          cfg,
		W:            w,
	}
	mock.lockOpenClaudeSession.Lock()
	mock.calls.OpenClaudeSession = append(mock.calls.OpenClaudeSession, callInfo)
	mock.lockOpenClaudeSession.Unlock()
	if mock.OpenClaudeSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.OpenClaudeSessionFunc(ctx, workID, projName, workDir, friendlyName, hooksEnv, cfg, w)
}

// OpenClaudeSessionCalls gets all the calls that were made to OpenClaudeSession.
// Check the length with:
//
//	len(mockedOrchestratorManager.OpenClaudeSessionCalls())
func (mock *OrchestratorManagerMock) OpenClaudeSessionCalls() []struct {
	Ctx          context.Context
	WorkID       string
	ProjName     string
	WorkDir      string
	FriendlyName string
	HooksEnv     []string
	Cfg          *project.Config
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		HooksEnv     []string
		Cfg          *project.Config
		W            io.Writer
	}
	mock.lockOpenClaudeSession.RLock()
	calls = mock.calls.OpenClaudeSession
	mock.lockOpenClaudeSession.RUnlock()
	return calls
}

// OpenConsole calls OpenConsoleFunc.
func (mock *OrchestratorManagerMock) OpenConsole(ctx context.Context, workID string, projName string, workDir string, friendlyName string, hooksEnv []string, w io.Writer) error {
	callInfo := struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		HooksEnv     []string
		W            io.Writer
	}{
		Ctx:          ctx,
		WorkID:       workID,
		ProjName:     projName,
		WorkDir:      workDir,
		FriendlyName: friendlyName,
		HooksEnv:     hooksEnv,
		W:            w,
	}
	mock.lockOpenConsole.Lock()
	mock.calls.OpenConsole = append(mock.calls.OpenConsole, callInfo)
	mock.lockOpenConsole.Unlock()
	if mock.OpenConsoleFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.OpenConsoleFunc(ctx, workID, projName, workDir, friendlyName, hooksEnv, w)
}

// OpenConsoleCalls gets all the calls that were made to OpenConsole.
// Check the length with:
//
//	len(mockedOrchestratorManager.OpenConsoleCalls())
func (mock *OrchestratorManagerMock) OpenConsoleCalls() []struct {
	Ctx          context.Context
	WorkID       string
	ProjName     string
	WorkDir      string
	FriendlyName string
	HooksEnv     []string
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		HooksEnv     []string
		W            io.Writer
	}
	mock.lockOpenConsole.RLock()
	calls = mock.calls.OpenConsole
	mock.lockOpenConsole.RUnlock()
	return calls
}

// SpawnPlanSession calls SpawnPlanSessionFunc.
func (mock *OrchestratorManagerMock) SpawnPlanSession(ctx context.Context, beadID string, projName string, mainRepoPath string, w io.Writer) error {
	callInfo := struct {
		Ctx          context.Context
		BeadID       string
		ProjName     string
		MainRepoPath string
		W            io.Writer
	}{
		Ctx:          ctx,
		BeadID:       beadID,
		ProjName:     projName,
		MainRepoPath: mainRepoPath,
		W:            w,
	}
	mock.lockSpawnPlanSession.Lock()
	mock.calls.SpawnPlanSession = append(mock.calls.SpawnPlanSession, callInfo)
	mock.lockSpawnPlanSession.Unlock()
	if mock.SpawnPlanSessionFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SpawnPlanSessionFunc(ctx, beadID, projName, mainRepoPath, w)
}

// SpawnPlanSessionCalls gets all the calls that were made to SpawnPlanSession.
// Check the length with:
//
//	len(mockedOrchestratorManager.SpawnPlanSessionCalls())
func (mock *OrchestratorManagerMock) SpawnPlanSessionCalls() []struct {
	Ctx          context.Context
	BeadID       string
	ProjName     string
	MainRepoPath string
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		BeadID       string
		ProjName     string
		MainRepoPath string
		W            io.Writer
	}
	mock.lockSpawnPlanSession.RLock()
	calls = mock.calls.SpawnPlanSession
	mock.lockSpawnPlanSession.RUnlock()
	return calls
}

// SpawnWorkOrchestrator calls SpawnWorkOrchestratorFunc.
func (mock *OrchestratorManagerMock) SpawnWorkOrchestrator(ctx context.Context, workID string, projName string, workDir string, friendlyName string, w io.Writer) error {
	callInfo := struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}{
		Ctx:          ctx,
		WorkID:       workID,
		ProjName:     projName,
		WorkDir:      workDir,
		FriendlyName: friendlyName,
		W:            w,
	}
	mock.lockSpawnWorkOrchestrator.Lock()
	mock.calls.SpawnWorkOrchestrator = append(mock.calls.SpawnWorkOrchestrator, callInfo)
	mock.lockSpawnWorkOrchestrator.Unlock()
	if mock.SpawnWorkOrchestratorFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SpawnWorkOrchestratorFunc(ctx, workID, projName, workDir, friendlyName, w)
}

// SpawnWorkOrchestratorCalls gets all the calls that were made to SpawnWorkOrchestrator.
// Check the length with:
//
//	len(mockedOrchestratorManager.SpawnWorkOrchestratorCalls())
func (mock *OrchestratorManagerMock) SpawnWorkOrchestratorCalls() []struct {
	Ctx          context.Context
	WorkID       string
	ProjName     string
	WorkDir      string
	FriendlyName string
	W            io.Writer
} {
	var calls []struct {
		Ctx          context.Context
		WorkID       string
		ProjName     string
		WorkDir      string
		FriendlyName string
		W            io.Writer
	}
	mock.lockSpawnWorkOrchestrator.RLock()
	calls = mock.calls.SpawnWorkOrchestrator
	mock.lockSpawnWorkOrchestrator.RUnlock()
	return calls
}

// TerminateWorkTabs calls TerminateWorkTabsFunc.
func (mock *OrchestratorManagerMock) TerminateWorkTabs(ctx context.Context, workID string, projName string, w io.Writer) error {
	callInfo := struct {
		Ctx      context.Context
		WorkID   string
		ProjName string
		W        io.Writer
	}{
		Ctx:      ctx,
		WorkID:   workID,
		ProjName: projName,
		W:        w,
	}
	mock.lockTerminateWorkTabs.Lock()
	mock.calls.TerminateWorkTabs = append(mock.calls.TerminateWorkTabs, callInfo)
	mock.lockTerminateWorkTabs.Unlock()
	if mock.TerminateWorkTabsFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TerminateWorkTabsFunc(ctx, workID, projName, w)
}

// TerminateWorkTabsCalls gets all the calls that were made to TerminateWorkTabs.
// Check the length with:
//
//	len(mockedOrchestratorManager.TerminateWorkTabsCalls())
func (mock *OrchestratorManagerMock) TerminateWorkTabsCalls() []struct {
	Ctx      context.Context
	WorkID   string
	ProjName string
	W        io.Writer
} {
	var calls []struct {
		Ctx      context.Context
		WorkID   string
		ProjName string
		W        io.Writer
	}
	mock.lockTerminateWorkTabs.RLock()
	calls = mock.calls.TerminateWorkTabs
	mock.lockTerminateWorkTabs.RUnlock()
	return calls
}
