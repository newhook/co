// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: works.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const addTaskToWork = `-- name: AddTaskToWork :exec
INSERT INTO work_tasks (work_id, task_id, position)
VALUES (?, ?, ?)
`

type AddTaskToWorkParams struct {
	WorkID   string `json:"work_id"`
	TaskID   string `json:"task_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddTaskToWork(ctx context.Context, arg AddTaskToWorkParams) error {
	_, err := q.db.ExecContext(ctx, addTaskToWork, arg.WorkID, arg.TaskID, arg.Position)
	return err
}

const completeWork = `-- name: CompleteWork :execrows
UPDATE works
SET status = 'completed',
    pr_url = ?,
    completed_at = ?
WHERE id = ?
`

type CompleteWorkParams struct {
	PrUrl       string       `json:"pr_url"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          string       `json:"id"`
}

func (q *Queries) CompleteWork(ctx context.Context, arg CompleteWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeWork, arg.PrUrl, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createWork = `-- name: CreateWork :exec
INSERT INTO works (id, status, name, worktree_path, branch_name, base_branch, root_issue_id, auto)
VALUES (?, 'pending', ?, ?, ?, ?, ?, ?)
`

type CreateWorkParams struct {
	ID           string `json:"id"`
	Name         string `json:"name"`
	WorktreePath string `json:"worktree_path"`
	BranchName   string `json:"branch_name"`
	BaseBranch   string `json:"base_branch"`
	RootIssueID  string `json:"root_issue_id"`
	Auto         bool   `json:"auto"`
}

func (q *Queries) CreateWork(ctx context.Context, arg CreateWorkParams) error {
	_, err := q.db.ExecContext(ctx, createWork,
		arg.ID,
		arg.Name,
		arg.WorktreePath,
		arg.BranchName,
		arg.BaseBranch,
		arg.RootIssueID,
		arg.Auto,
	)
	return err
}

const deleteWork = `-- name: DeleteWork :execrows
DELETE FROM works
WHERE id = ?
`

func (q *Queries) DeleteWork(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWork, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWorkTasks = `-- name: DeleteWorkTasks :execrows
DELETE FROM work_tasks
WHERE work_id = ?
`

func (q *Queries) DeleteWorkTasks(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkTasks, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failWork = `-- name: FailWork :execrows
UPDATE works
SET status = 'failed',
    error_message = ?,
    completed_at = ?
WHERE id = ?
`

type FailWorkParams struct {
	ErrorMessage string       `json:"error_message"`
	CompletedAt  sql.NullTime `json:"completed_at"`
	ID           string       `json:"id"`
}

func (q *Queries) FailWork(ctx context.Context, arg FailWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failWork, arg.ErrorMessage, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAndIncrementTaskCounter = `-- name: GetAndIncrementTaskCounter :one
UPDATE work_task_counters
SET next_task_num = next_task_num + 1
WHERE work_id = ?
RETURNING next_task_num - 1 as task_num
`

func (q *Queries) GetAndIncrementTaskCounter(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAndIncrementTaskCounter, workID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getLastWorkID = `-- name: GetLastWorkID :one
SELECT id FROM works
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastWorkID(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastWorkID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getWork = `-- name: GetWork :one
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
WHERE id = ?
`

func (q *Queries) GetWork(ctx context.Context, id string) (Work, error) {
	row := q.db.QueryRowContext(ctx, getWork, id)
	var i Work
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.ZellijSession,
		&i.ZellijTab,
		&i.WorktreePath,
		&i.BranchName,
		&i.BaseBranch,
		&i.RootIssueID,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.Auto,
		&i.CiStatus,
		&i.ApprovalStatus,
		&i.Approvers,
		&i.LastPrPollAt,
		&i.HasUnseenPrChanges,
		&i.PrState,
	)
	return i, err
}

const getWorkByDirectory = `-- name: GetWorkByDirectory :one
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
WHERE worktree_path LIKE ?
LIMIT 1
`

func (q *Queries) GetWorkByDirectory(ctx context.Context, worktreePath string) (Work, error) {
	row := q.db.QueryRowContext(ctx, getWorkByDirectory, worktreePath)
	var i Work
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Name,
		&i.ZellijSession,
		&i.ZellijTab,
		&i.WorktreePath,
		&i.BranchName,
		&i.BaseBranch,
		&i.RootIssueID,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.Auto,
		&i.CiStatus,
		&i.ApprovalStatus,
		&i.Approvers,
		&i.LastPrPollAt,
		&i.HasUnseenPrChanges,
		&i.PrState,
	)
	return i, err
}

const getWorkTasks = `-- name: GetWorkTasks :many
SELECT t.id, t.status,
       COALESCE(t.task_type, 'implement') as task_type,
       t.complexity_budget,
       t.actual_complexity,
       t.work_id,
       t.worktree_path,
       t.pr_url,
       t.error_message,
       t.started_at,
       t.completed_at,
       t.created_at,
       t.spawned_at,
       t.spawn_status
FROM tasks t
JOIN work_tasks wt ON t.id = wt.task_id
WHERE wt.work_id = ?
ORDER BY wt.position
`

type GetWorkTasksRow struct {
	ID               string       `json:"id"`
	Status           string       `json:"status"`
	TaskType         string       `json:"task_type"`
	ComplexityBudget int64        `json:"complexity_budget"`
	ActualComplexity int64        `json:"actual_complexity"`
	WorkID           string       `json:"work_id"`
	WorktreePath     string       `json:"worktree_path"`
	PrUrl            string       `json:"pr_url"`
	ErrorMessage     string       `json:"error_message"`
	StartedAt        sql.NullTime `json:"started_at"`
	CompletedAt      sql.NullTime `json:"completed_at"`
	CreatedAt        time.Time    `json:"created_at"`
	SpawnedAt        sql.NullTime `json:"spawned_at"`
	SpawnStatus      string       `json:"spawn_status"`
}

func (q *Queries) GetWorkTasks(ctx context.Context, workID string) ([]GetWorkTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getWorkTasks, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetWorkTasksRow{}
	for rows.Next() {
		var i GetWorkTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorksWithPRs = `-- name: GetWorksWithPRs :many
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
WHERE pr_url != ''
ORDER BY created_at DESC
`

func (q *Queries) GetWorksWithPRs(ctx context.Context) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, getWorksWithPRs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.RootIssueID,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.Auto,
			&i.CiStatus,
			&i.ApprovalStatus,
			&i.Approvers,
			&i.LastPrPollAt,
			&i.HasUnseenPrChanges,
			&i.PrState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorksWithUnseenChanges = `-- name: GetWorksWithUnseenChanges :many
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
WHERE has_unseen_pr_changes = TRUE
ORDER BY created_at DESC
`

func (q *Queries) GetWorksWithUnseenChanges(ctx context.Context) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, getWorksWithUnseenChanges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.RootIssueID,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.Auto,
			&i.CiStatus,
			&i.ApprovalStatus,
			&i.Approvers,
			&i.LastPrPollAt,
			&i.HasUnseenPrChanges,
			&i.PrState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const idleWork = `-- name: IdleWork :execrows
UPDATE works
SET status = 'idle'
WHERE id = ?
`

func (q *Queries) IdleWork(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, idleWork, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const idleWorkWithPR = `-- name: IdleWorkWithPR :execrows
UPDATE works
SET status = 'idle',
    pr_url = ?
WHERE id = ?
`

type IdleWorkWithPRParams struct {
	PrUrl string `json:"pr_url"`
	ID    string `json:"id"`
}

func (q *Queries) IdleWorkWithPR(ctx context.Context, arg IdleWorkWithPRParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, idleWorkWithPR, arg.PrUrl, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const initializeTaskCounter = `-- name: InitializeTaskCounter :exec
INSERT INTO work_task_counters (work_id, next_task_num)
VALUES (?, 1)
ON CONFLICT (work_id) DO NOTHING
`

func (q *Queries) InitializeTaskCounter(ctx context.Context, workID string) error {
	_, err := q.db.ExecContext(ctx, initializeTaskCounter, workID)
	return err
}

const listWorks = `-- name: ListWorks :many
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
ORDER BY created_at DESC
`

func (q *Queries) ListWorks(ctx context.Context) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, listWorks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.RootIssueID,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.Auto,
			&i.CiStatus,
			&i.ApprovalStatus,
			&i.Approvers,
			&i.LastPrPollAt,
			&i.HasUnseenPrChanges,
			&i.PrState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorksByStatus = `-- name: ListWorksByStatus :many
SELECT id, status,
       name,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       root_issue_id,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       auto,
       ci_status,
       approval_status,
       approvers,
       last_pr_poll_at,
       has_unseen_pr_changes,
       pr_state
FROM works
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListWorksByStatus(ctx context.Context, status string) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, listWorksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Name,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.RootIssueID,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.Auto,
			&i.CiStatus,
			&i.ApprovalStatus,
			&i.Approvers,
			&i.LastPrPollAt,
			&i.HasUnseenPrChanges,
			&i.PrState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markWorkPRSeen = `-- name: MarkWorkPRSeen :execrows
UPDATE works
SET has_unseen_pr_changes = FALSE
WHERE id = ?
`

func (q *Queries) MarkWorkPRSeen(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, markWorkPRSeen, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const mergeWork = `-- name: MergeWork :execrows
UPDATE works
SET status = 'merged',
    pr_state = 'merged',
    completed_at = ?
WHERE id = ?
`

type MergeWorkParams struct {
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          string       `json:"id"`
}

func (q *Queries) MergeWork(ctx context.Context, arg MergeWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, mergeWork, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const restartWork = `-- name: RestartWork :execrows
UPDATE works
SET status = 'processing',
    error_message = ''
WHERE id = ? AND status = 'failed'
`

func (q *Queries) RestartWork(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, restartWork, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resumeWork = `-- name: ResumeWork :execrows
UPDATE works
SET status = 'processing'
WHERE id = ? AND status IN ('idle', 'completed')
`

func (q *Queries) ResumeWork(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, resumeWork, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setWorkHasUnseenPRChanges = `-- name: SetWorkHasUnseenPRChanges :execrows
UPDATE works
SET has_unseen_pr_changes = ?
WHERE id = ?
`

type SetWorkHasUnseenPRChangesParams struct {
	HasUnseenPrChanges bool   `json:"has_unseen_pr_changes"`
	ID                 string `json:"id"`
}

func (q *Queries) SetWorkHasUnseenPRChanges(ctx context.Context, arg SetWorkHasUnseenPRChangesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, setWorkHasUnseenPRChanges, arg.HasUnseenPrChanges, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const startWork = `-- name: StartWork :execrows
UPDATE works
SET status = 'processing',
    zellij_session = ?,
    zellij_tab = ?,
    started_at = ?
WHERE id = ?
`

type StartWorkParams struct {
	ZellijSession string       `json:"zellij_session"`
	ZellijTab     string       `json:"zellij_tab"`
	StartedAt     sql.NullTime `json:"started_at"`
	ID            string       `json:"id"`
}

func (q *Queries) StartWork(ctx context.Context, arg StartWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, startWork,
		arg.ZellijSession,
		arg.ZellijTab,
		arg.StartedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWorkPRStatus = `-- name: UpdateWorkPRStatus :execrows
UPDATE works
SET ci_status = ?,
    approval_status = ?,
    approvers = ?,
    pr_state = ?,
    last_pr_poll_at = ?
WHERE id = ?
`

type UpdateWorkPRStatusParams struct {
	CiStatus       string       `json:"ci_status"`
	ApprovalStatus string       `json:"approval_status"`
	Approvers      string       `json:"approvers"`
	PrState        string       `json:"pr_state"`
	LastPrPollAt   sql.NullTime `json:"last_pr_poll_at"`
	ID             string       `json:"id"`
}

func (q *Queries) UpdateWorkPRStatus(ctx context.Context, arg UpdateWorkPRStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateWorkPRStatus,
		arg.CiStatus,
		arg.ApprovalStatus,
		arg.Approvers,
		arg.PrState,
		arg.LastPrPollAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWorkWorktreePath = `-- name: UpdateWorkWorktreePath :execrows
UPDATE works
SET worktree_path = ?
WHERE id = ?
`

type UpdateWorkWorktreePathParams struct {
	WorktreePath string `json:"worktree_path"`
	ID           string `json:"id"`
}

func (q *Queries) UpdateWorkWorktreePath(ctx context.Context, arg UpdateWorkWorktreePathParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateWorkWorktreePath, arg.WorktreePath, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
