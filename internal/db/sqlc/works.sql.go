// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: works.sql

package sqlc

import (
	"context"
	"database/sql"
)

const addTaskToWork = `-- name: AddTaskToWork :exec
INSERT INTO work_tasks (work_id, task_id, position)
VALUES (?, ?, ?)
`

type AddTaskToWorkParams struct {
	WorkID   string `json:"work_id"`
	TaskID   string `json:"task_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddTaskToWork(ctx context.Context, arg AddTaskToWorkParams) error {
	_, err := q.db.ExecContext(ctx, addTaskToWork, arg.WorkID, arg.TaskID, arg.Position)
	return err
}

const completeWork = `-- name: CompleteWork :execrows
UPDATE works
SET status = 'completed',
    pr_url = ?,
    completed_at = ?
WHERE id = ?
`

type CompleteWorkParams struct {
	PrUrl       string       `json:"pr_url"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          string       `json:"id"`
}

func (q *Queries) CompleteWork(ctx context.Context, arg CompleteWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeWork, arg.PrUrl, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createWork = `-- name: CreateWork :exec
INSERT INTO works (id, status, worktree_path, branch_name, base_branch)
VALUES (?, 'pending', ?, ?, ?)
`

type CreateWorkParams struct {
	ID           string `json:"id"`
	WorktreePath string `json:"worktree_path"`
	BranchName   string `json:"branch_name"`
	BaseBranch   string `json:"base_branch"`
}

func (q *Queries) CreateWork(ctx context.Context, arg CreateWorkParams) error {
	_, err := q.db.ExecContext(ctx, createWork,
		arg.ID,
		arg.WorktreePath,
		arg.BranchName,
		arg.BaseBranch,
	)
	return err
}

const deleteWork = `-- name: DeleteWork :execrows
DELETE FROM works
WHERE id = ?
`

func (q *Queries) DeleteWork(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWork, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWorkTasks = `-- name: DeleteWorkTasks :execrows
DELETE FROM work_tasks
WHERE work_id = ?
`

func (q *Queries) DeleteWorkTasks(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkTasks, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failWork = `-- name: FailWork :execrows
UPDATE works
SET status = 'failed',
    error_message = ?,
    completed_at = ?
WHERE id = ?
`

type FailWorkParams struct {
	ErrorMessage string       `json:"error_message"`
	CompletedAt  sql.NullTime `json:"completed_at"`
	ID           string       `json:"id"`
}

func (q *Queries) FailWork(ctx context.Context, arg FailWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failWork, arg.ErrorMessage, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAndIncrementTaskCounter = `-- name: GetAndIncrementTaskCounter :one
UPDATE work_task_counters
SET next_task_num = next_task_num + 1
WHERE work_id = ?
RETURNING next_task_num - 1 as task_num
`

func (q *Queries) GetAndIncrementTaskCounter(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAndIncrementTaskCounter, workID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getLastWorkID = `-- name: GetLastWorkID :one
SELECT id FROM works
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLastWorkID(ctx context.Context) (string, error) {
	row := q.db.QueryRowContext(ctx, getLastWorkID)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getWork = `-- name: GetWork :one
SELECT id, status,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM works
WHERE id = ?
`

func (q *Queries) GetWork(ctx context.Context, id string) (Work, error) {
	row := q.db.QueryRowContext(ctx, getWork, id)
	var i Work
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ZellijSession,
		&i.ZellijTab,
		&i.WorktreePath,
		&i.BranchName,
		&i.BaseBranch,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWorkByDirectory = `-- name: GetWorkByDirectory :one
SELECT id, status,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM works
WHERE worktree_path LIKE ?
LIMIT 1
`

func (q *Queries) GetWorkByDirectory(ctx context.Context, worktreePath string) (Work, error) {
	row := q.db.QueryRowContext(ctx, getWorkByDirectory, worktreePath)
	var i Work
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.ZellijSession,
		&i.ZellijTab,
		&i.WorktreePath,
		&i.BranchName,
		&i.BaseBranch,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getWorkTasks = `-- name: GetWorkTasks :many
SELECT t.id, t.status,
       COALESCE(t.task_type, 'implement') as task_type,
       t.complexity_budget,
       t.actual_complexity,
       t.work_id,
       t.worktree_path,
       t.pr_url,
       t.error_message,
       t.started_at,
       t.completed_at,
       t.created_at,
       t.spawned_at,
       t.spawn_status
FROM tasks t
JOIN work_tasks wt ON t.id = wt.task_id
WHERE wt.work_id = ?
ORDER BY wt.position
`

func (q *Queries) GetWorkTasks(ctx context.Context, workID string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getWorkTasks, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initializeTaskCounter = `-- name: InitializeTaskCounter :exec
INSERT INTO work_task_counters (work_id, next_task_num)
VALUES (?, 1)
ON CONFLICT (work_id) DO NOTHING
`

func (q *Queries) InitializeTaskCounter(ctx context.Context, workID string) error {
	_, err := q.db.ExecContext(ctx, initializeTaskCounter, workID)
	return err
}

const listWorks = `-- name: ListWorks :many
SELECT id, status,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM works
ORDER BY created_at DESC
`

func (q *Queries) ListWorks(ctx context.Context) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, listWorks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorksByStatus = `-- name: ListWorksByStatus :many
SELECT id, status,
       zellij_session,
       zellij_tab,
       worktree_path,
       branch_name,
       base_branch,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM works
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListWorksByStatus(ctx context.Context, status string) ([]Work, error) {
	rows, err := q.db.QueryContext(ctx, listWorksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Work{}
	for rows.Next() {
		var i Work
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.ZellijSession,
			&i.ZellijTab,
			&i.WorktreePath,
			&i.BranchName,
			&i.BaseBranch,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startWork = `-- name: StartWork :execrows
UPDATE works
SET status = 'processing',
    zellij_session = ?,
    zellij_tab = ?,
    started_at = ?
WHERE id = ?
`

type StartWorkParams struct {
	ZellijSession string       `json:"zellij_session"`
	ZellijTab     string       `json:"zellij_tab"`
	StartedAt     sql.NullTime `json:"started_at"`
	ID            string       `json:"id"`
}

func (q *Queries) StartWork(ctx context.Context, arg StartWorkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, startWork,
		arg.ZellijSession,
		arg.ZellijTab,
		arg.StartedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
