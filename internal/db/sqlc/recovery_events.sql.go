// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: recovery_events.sql

package sqlc

import (
	"context"
	"database/sql"
)

const getRecentRecoveryEvents = `-- name: GetRecentRecoveryEvents :many
SELECT id, event_type, task_id, work_id, bead_id, reason, details, created_at
FROM recovery_events
ORDER BY created_at DESC
LIMIT ?
`

func (q *Queries) GetRecentRecoveryEvents(ctx context.Context, limit int64) ([]RecoveryEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecentRecoveryEvents, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecoveryEvent{}
	for rows.Next() {
		var i RecoveryEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.TaskID,
			&i.WorkID,
			&i.BeadID,
			&i.Reason,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecoveryEventsForTask = `-- name: GetRecoveryEventsForTask :many
SELECT id, event_type, task_id, work_id, bead_id, reason, details, created_at
FROM recovery_events
WHERE task_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetRecoveryEventsForTask(ctx context.Context, taskID string) ([]RecoveryEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecoveryEventsForTask, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecoveryEvent{}
	for rows.Next() {
		var i RecoveryEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.TaskID,
			&i.WorkID,
			&i.BeadID,
			&i.Reason,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecoveryEventsForWork = `-- name: GetRecoveryEventsForWork :many
SELECT id, event_type, task_id, work_id, bead_id, reason, details, created_at
FROM recovery_events
WHERE work_id = ?
ORDER BY created_at DESC
`

func (q *Queries) GetRecoveryEventsForWork(ctx context.Context, workID string) ([]RecoveryEvent, error) {
	rows, err := q.db.QueryContext(ctx, getRecoveryEventsForWork, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecoveryEvent{}
	for rows.Next() {
		var i RecoveryEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.TaskID,
			&i.WorkID,
			&i.BeadID,
			&i.Reason,
			&i.Details,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRecoveryEvent = `-- name: InsertRecoveryEvent :exec
INSERT INTO recovery_events (event_type, task_id, work_id, bead_id, reason, details)
VALUES (?, ?, ?, ?, ?, ?)
`

type InsertRecoveryEventParams struct {
	EventType string         `json:"event_type"`
	TaskID    string         `json:"task_id"`
	WorkID    string         `json:"work_id"`
	BeadID    sql.NullString `json:"bead_id"`
	Reason    string         `json:"reason"`
	Details   sql.NullString `json:"details"`
}

func (q *Queries) InsertRecoveryEvent(ctx context.Context, arg InsertRecoveryEventParams) error {
	_, err := q.db.ExecContext(ctx, insertRecoveryEvent,
		arg.EventType,
		arg.TaskID,
		arg.WorkID,
		arg.BeadID,
		arg.Reason,
		arg.Details,
	)
	return err
}
