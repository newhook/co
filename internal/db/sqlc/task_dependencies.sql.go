// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: task_dependencies.sql

package sqlc

import (
	"context"
)

const addTaskDependency = `-- name: AddTaskDependency :exec
INSERT INTO task_dependencies (task_id, depends_on_task_id)
VALUES (?, ?)
`

type AddTaskDependencyParams struct {
	TaskID          string `json:"task_id"`
	DependsOnTaskID string `json:"depends_on_task_id"`
}

func (q *Queries) AddTaskDependency(ctx context.Context, arg AddTaskDependencyParams) error {
	_, err := q.db.ExecContext(ctx, addTaskDependency, arg.TaskID, arg.DependsOnTaskID)
	return err
}

const deleteTaskDependencies = `-- name: DeleteTaskDependencies :execrows
DELETE FROM task_dependencies
WHERE task_id = ?
`

func (q *Queries) DeleteTaskDependencies(ctx context.Context, taskID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTaskDependencies, taskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTaskDependenciesForWork = `-- name: DeleteTaskDependenciesForWork :execrows
DELETE FROM task_dependencies
WHERE task_id IN (
    SELECT task_id FROM work_tasks WHERE work_id = ?
)
`

func (q *Queries) DeleteTaskDependenciesForWork(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTaskDependenciesForWork, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTaskDependency = `-- name: DeleteTaskDependency :execrows
DELETE FROM task_dependencies
WHERE task_id = ? AND depends_on_task_id = ?
`

type DeleteTaskDependencyParams struct {
	TaskID          string `json:"task_id"`
	DependsOnTaskID string `json:"depends_on_task_id"`
}

func (q *Queries) DeleteTaskDependency(ctx context.Context, arg DeleteTaskDependencyParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTaskDependency, arg.TaskID, arg.DependsOnTaskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getReadyTasksForWork = `-- name: GetReadyTasksForWork :many
SELECT t.id, t.status,
       COALESCE(t.task_type, 'implement') as task_type,
       t.complexity_budget,
       t.actual_complexity,
       t.work_id,
       t.worktree_path,
       t.pr_url,
       t.error_message,
       t.started_at,
       t.completed_at,
       t.created_at,
       t.spawned_at,
       t.spawn_status
FROM tasks t
INNER JOIN work_tasks wt ON t.id = wt.task_id
WHERE wt.work_id = ?
  AND t.status = 'pending'
  AND NOT EXISTS (
      SELECT 1 FROM task_dependencies td
      INNER JOIN tasks dep ON td.depends_on_task_id = dep.id
      WHERE td.task_id = t.id
        AND dep.status != 'completed'
  )
ORDER BY wt.position ASC
`

func (q *Queries) GetReadyTasksForWork(ctx context.Context, workID string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getReadyTasksForWork, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskDependencies = `-- name: GetTaskDependencies :many
SELECT depends_on_task_id
FROM task_dependencies
WHERE task_id = ?
`

func (q *Queries) GetTaskDependencies(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskDependencies, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var depends_on_task_id string
		if err := rows.Scan(&depends_on_task_id); err != nil {
			return nil, err
		}
		items = append(items, depends_on_task_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskDependents = `-- name: GetTaskDependents :many
SELECT task_id
FROM task_dependencies
WHERE depends_on_task_id = ?
`

func (q *Queries) GetTaskDependents(ctx context.Context, dependsOnTaskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskDependents, dependsOnTaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var task_id string
		if err := rows.Scan(&task_id); err != nil {
			return nil, err
		}
		items = append(items, task_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasPendingDependencies = `-- name: HasPendingDependencies :one
SELECT COUNT(*) > 0 as has_pending
FROM task_dependencies td
INNER JOIN tasks dep ON td.depends_on_task_id = dep.id
WHERE td.task_id = ?
  AND dep.status != 'completed'
`

func (q *Queries) HasPendingDependencies(ctx context.Context, taskID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasPendingDependencies, taskID)
	var has_pending bool
	err := row.Scan(&has_pending)
	return has_pending, err
}
