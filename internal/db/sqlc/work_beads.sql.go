// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: work_beads.sql

package sqlc

import (
	"context"
)

const addWorkBead = `-- name: AddWorkBead :exec
INSERT INTO work_beads (work_id, bead_id, group_id, position)
VALUES (?, ?, ?, ?)
`

type AddWorkBeadParams struct {
	WorkID   string `json:"work_id"`
	BeadID   string `json:"bead_id"`
	GroupID  int64  `json:"group_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddWorkBead(ctx context.Context, arg AddWorkBeadParams) error {
	_, err := q.db.ExecContext(ctx, addWorkBead,
		arg.WorkID,
		arg.BeadID,
		arg.GroupID,
		arg.Position,
	)
	return err
}

const addWorkBeadsBatch = `-- name: AddWorkBeadsBatch :exec
INSERT INTO work_beads (work_id, bead_id, group_id, position)
VALUES (?, ?, ?, ?)
ON CONFLICT (work_id, bead_id) DO UPDATE SET
    group_id = excluded.group_id,
    position = excluded.position
`

type AddWorkBeadsBatchParams struct {
	WorkID   string `json:"work_id"`
	BeadID   string `json:"bead_id"`
	GroupID  int64  `json:"group_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddWorkBeadsBatch(ctx context.Context, arg AddWorkBeadsBatchParams) error {
	_, err := q.db.ExecContext(ctx, addWorkBeadsBatch,
		arg.WorkID,
		arg.BeadID,
		arg.GroupID,
		arg.Position,
	)
	return err
}

const deleteWorkBeads = `-- name: DeleteWorkBeads :execrows
DELETE FROM work_beads
WHERE work_id = ?
`

func (q *Queries) DeleteWorkBeads(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkBeads, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllAssignedBeads = `-- name: GetAllAssignedBeads :many
SELECT bead_id, work_id
FROM work_beads
ORDER BY bead_id
`

type GetAllAssignedBeadsRow struct {
	BeadID string `json:"bead_id"`
	WorkID string `json:"work_id"`
}

// Returns all beads assigned to any work, with their work ID.
// This is used by plan mode to show which beads are already assigned.
func (q *Queries) GetAllAssignedBeads(ctx context.Context) ([]GetAllAssignedBeadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAssignedBeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAssignedBeadsRow{}
	for rows.Next() {
		var i GetAllAssignedBeadsRow
		if err := rows.Scan(&i.BeadID, &i.WorkID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAndIncrementBeadGroupCounter = `-- name: GetAndIncrementBeadGroupCounter :one
UPDATE work_bead_group_counters
SET next_group_id = next_group_id + 1
WHERE work_id = ?
RETURNING next_group_id - 1 as group_id
`

func (q *Queries) GetAndIncrementBeadGroupCounter(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAndIncrementBeadGroupCounter, workID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getMaxWorkBeadPosition = `-- name: GetMaxWorkBeadPosition :one
SELECT CAST(COALESCE(MAX(position), -1) AS INTEGER) as max_position
FROM work_beads
WHERE work_id = ?
`

func (q *Queries) GetMaxWorkBeadPosition(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMaxWorkBeadPosition, workID)
	var max_position int64
	err := row.Scan(&max_position)
	return max_position, err
}

const getUnassignedWorkBeads = `-- name: GetUnassignedWorkBeads :many
SELECT wb.work_id, wb.bead_id, wb.group_id, wb.position, wb.created_at
FROM work_beads wb
WHERE wb.work_id = ?
  AND NOT EXISTS (
    SELECT 1 FROM task_beads tb
    JOIN work_tasks wt ON tb.task_id = wt.task_id
    WHERE wt.work_id = wb.work_id AND tb.bead_id = wb.bead_id
  )
ORDER BY wb.position
`

func (q *Queries) GetUnassignedWorkBeads(ctx context.Context, workID string) ([]WorkBead, error) {
	rows, err := q.db.QueryContext(ctx, getUnassignedWorkBeads, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkBead{}
	for rows.Next() {
		var i WorkBead
		if err := rows.Scan(
			&i.WorkID,
			&i.BeadID,
			&i.GroupID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkBeadGroups = `-- name: GetWorkBeadGroups :many
SELECT DISTINCT group_id
FROM work_beads
WHERE work_id = ? AND group_id > 0
ORDER BY group_id
`

func (q *Queries) GetWorkBeadGroups(ctx context.Context, workID string) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getWorkBeadGroups, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var group_id int64
		if err := rows.Scan(&group_id); err != nil {
			return nil, err
		}
		items = append(items, group_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkBeads = `-- name: GetWorkBeads :many
SELECT work_id, bead_id, group_id, position, created_at
FROM work_beads
WHERE work_id = ?
ORDER BY position
`

func (q *Queries) GetWorkBeads(ctx context.Context, workID string) ([]WorkBead, error) {
	rows, err := q.db.QueryContext(ctx, getWorkBeads, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkBead{}
	for rows.Next() {
		var i WorkBead
		if err := rows.Scan(
			&i.WorkID,
			&i.BeadID,
			&i.GroupID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkBeadsByGroup = `-- name: GetWorkBeadsByGroup :many
SELECT work_id, bead_id, group_id, position, created_at
FROM work_beads
WHERE work_id = ? AND group_id = ?
ORDER BY position
`

type GetWorkBeadsByGroupParams struct {
	WorkID  string `json:"work_id"`
	GroupID int64  `json:"group_id"`
}

func (q *Queries) GetWorkBeadsByGroup(ctx context.Context, arg GetWorkBeadsByGroupParams) ([]WorkBead, error) {
	rows, err := q.db.QueryContext(ctx, getWorkBeadsByGroup, arg.WorkID, arg.GroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkBead{}
	for rows.Next() {
		var i WorkBead
		if err := rows.Scan(
			&i.WorkID,
			&i.BeadID,
			&i.GroupID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initializeBeadGroupCounter = `-- name: InitializeBeadGroupCounter :exec
INSERT INTO work_bead_group_counters (work_id, next_group_id)
VALUES (?, 1)
ON CONFLICT (work_id) DO NOTHING
`

func (q *Queries) InitializeBeadGroupCounter(ctx context.Context, workID string) error {
	_, err := q.db.ExecContext(ctx, initializeBeadGroupCounter, workID)
	return err
}

const isBeadInTask = `-- name: IsBeadInTask :one
SELECT COUNT(*) > 0 as in_task
FROM task_beads tb
JOIN work_tasks wt ON tb.task_id = wt.task_id
WHERE wt.work_id = ? AND tb.bead_id = ?
`

type IsBeadInTaskParams struct {
	WorkID string `json:"work_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) IsBeadInTask(ctx context.Context, arg IsBeadInTaskParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isBeadInTask, arg.WorkID, arg.BeadID)
	var in_task bool
	err := row.Scan(&in_task)
	return in_task, err
}

const removeWorkBead = `-- name: RemoveWorkBead :execrows
DELETE FROM work_beads
WHERE work_id = ? AND bead_id = ?
`

type RemoveWorkBeadParams struct {
	WorkID string `json:"work_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) RemoveWorkBead(ctx context.Context, arg RemoveWorkBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeWorkBead, arg.WorkID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateWorkBeadGroup = `-- name: UpdateWorkBeadGroup :execrows
UPDATE work_beads
SET group_id = ?
WHERE work_id = ? AND bead_id = ?
`

type UpdateWorkBeadGroupParams struct {
	GroupID int64  `json:"group_id"`
	WorkID  string `json:"work_id"`
	BeadID  string `json:"bead_id"`
}

func (q *Queries) UpdateWorkBeadGroup(ctx context.Context, arg UpdateWorkBeadGroupParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateWorkBeadGroup, arg.GroupID, arg.WorkID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
