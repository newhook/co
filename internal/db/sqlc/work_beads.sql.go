// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: work_beads.sql

package sqlc

import (
	"context"
)

const addWorkBead = `-- name: AddWorkBead :exec
INSERT INTO work_beads (work_id, bead_id, position)
VALUES (?, ?, ?)
`

type AddWorkBeadParams struct {
	WorkID   string `json:"work_id"`
	BeadID   string `json:"bead_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddWorkBead(ctx context.Context, arg AddWorkBeadParams) error {
	_, err := q.db.ExecContext(ctx, addWorkBead, arg.WorkID, arg.BeadID, arg.Position)
	return err
}

const addWorkBeadsBatch = `-- name: AddWorkBeadsBatch :exec
INSERT INTO work_beads (work_id, bead_id, position)
VALUES (?, ?, ?)
ON CONFLICT (work_id, bead_id) DO UPDATE SET
    position = excluded.position
`

type AddWorkBeadsBatchParams struct {
	WorkID   string `json:"work_id"`
	BeadID   string `json:"bead_id"`
	Position int64  `json:"position"`
}

func (q *Queries) AddWorkBeadsBatch(ctx context.Context, arg AddWorkBeadsBatchParams) error {
	_, err := q.db.ExecContext(ctx, addWorkBeadsBatch, arg.WorkID, arg.BeadID, arg.Position)
	return err
}

const deleteWorkBeads = `-- name: DeleteWorkBeads :execrows
DELETE FROM work_beads
WHERE work_id = ?
`

func (q *Queries) DeleteWorkBeads(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkBeads, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAllAssignedBeads = `-- name: GetAllAssignedBeads :many
SELECT bead_id, work_id
FROM work_beads
ORDER BY bead_id
`

type GetAllAssignedBeadsRow struct {
	BeadID string `json:"bead_id"`
	WorkID string `json:"work_id"`
}

// Returns all beads assigned to any work, with their work ID.
// This is used by plan mode to show which beads are already assigned.
func (q *Queries) GetAllAssignedBeads(ctx context.Context) ([]GetAllAssignedBeadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllAssignedBeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAssignedBeadsRow{}
	for rows.Next() {
		var i GetAllAssignedBeadsRow
		if err := rows.Scan(&i.BeadID, &i.WorkID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMaxWorkBeadPosition = `-- name: GetMaxWorkBeadPosition :one
SELECT CAST(COALESCE(MAX(position), -1) AS INTEGER) as max_position
FROM work_beads
WHERE work_id = ?
`

func (q *Queries) GetMaxWorkBeadPosition(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getMaxWorkBeadPosition, workID)
	var max_position int64
	err := row.Scan(&max_position)
	return max_position, err
}

const getUnassignedWorkBeads = `-- name: GetUnassignedWorkBeads :many
SELECT wb.work_id, wb.bead_id, wb.position, wb.created_at
FROM work_beads wb
WHERE wb.work_id = ?
  AND NOT EXISTS (
    SELECT 1 FROM task_beads tb
    JOIN work_tasks wt ON tb.task_id = wt.task_id
    WHERE wt.work_id = wb.work_id AND tb.bead_id = wb.bead_id
  )
ORDER BY wb.position
`

func (q *Queries) GetUnassignedWorkBeads(ctx context.Context, workID string) ([]WorkBead, error) {
	rows, err := q.db.QueryContext(ctx, getUnassignedWorkBeads, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkBead{}
	for rows.Next() {
		var i WorkBead
		if err := rows.Scan(
			&i.WorkID,
			&i.BeadID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWorkBeads = `-- name: GetWorkBeads :many
SELECT work_id, bead_id, position, created_at
FROM work_beads
WHERE work_id = ?
ORDER BY position
`

func (q *Queries) GetWorkBeads(ctx context.Context, workID string) ([]WorkBead, error) {
	rows, err := q.db.QueryContext(ctx, getWorkBeads, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []WorkBead{}
	for rows.Next() {
		var i WorkBead
		if err := rows.Scan(
			&i.WorkID,
			&i.BeadID,
			&i.Position,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isBeadInTask = `-- name: IsBeadInTask :one
SELECT COUNT(*) > 0 as in_task
FROM task_beads tb
JOIN work_tasks wt ON tb.task_id = wt.task_id
WHERE wt.work_id = ? AND tb.bead_id = ?
`

type IsBeadInTaskParams struct {
	WorkID string `json:"work_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) IsBeadInTask(ctx context.Context, arg IsBeadInTaskParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isBeadInTask, arg.WorkID, arg.BeadID)
	var in_task bool
	err := row.Scan(&in_task)
	return in_task, err
}

const removeWorkBead = `-- name: RemoveWorkBead :execrows
DELETE FROM work_beads
WHERE work_id = ? AND bead_id = ?
`

type RemoveWorkBeadParams struct {
	WorkID string `json:"work_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) RemoveWorkBead(ctx context.Context, arg RemoveWorkBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeWorkBead, arg.WorkID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
