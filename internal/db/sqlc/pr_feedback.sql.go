// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: pr_feedback.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const countUnassignedFeedbackForWork = `-- name: CountUnassignedFeedbackForWork :one
SELECT COUNT(*) as count FROM pr_feedback pf
WHERE pf.work_id = ?
  AND pf.bead_id IS NOT NULL
  AND pf.resolved_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM task_beads tb
    JOIN tasks t ON tb.task_id = t.id
    WHERE tb.bead_id = pf.bead_id
      AND t.work_id = pf.work_id
  )
`

// Count PR feedback items that have beads which are not yet assigned to any task and not resolved/closed.
func (q *Queries) CountUnassignedFeedbackForWork(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnassignedFeedbackForWork, workID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPRFeedback = `-- name: CreatePRFeedback :exec
INSERT INTO pr_feedback (
    id, work_id, pr_url, feedback_type, title, description,
    source, source_url, source_id, priority, bead_id, metadata,
    source_type, source_name, context
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreatePRFeedbackParams struct {
	ID           string         `json:"id"`
	WorkID       string         `json:"work_id"`
	PrUrl        string         `json:"pr_url"`
	FeedbackType string         `json:"feedback_type"`
	Title        string         `json:"title"`
	Description  string         `json:"description"`
	Source       string         `json:"source"`
	SourceUrl    sql.NullString `json:"source_url"`
	SourceID     sql.NullString `json:"source_id"`
	Priority     int64          `json:"priority"`
	BeadID       sql.NullString `json:"bead_id"`
	Metadata     string         `json:"metadata"`
	SourceType   sql.NullString `json:"source_type"`
	SourceName   sql.NullString `json:"source_name"`
	Context      sql.NullString `json:"context"`
}

func (q *Queries) CreatePRFeedback(ctx context.Context, arg CreatePRFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, createPRFeedback,
		arg.ID,
		arg.WorkID,
		arg.PrUrl,
		arg.FeedbackType,
		arg.Title,
		arg.Description,
		arg.Source,
		arg.SourceUrl,
		arg.SourceID,
		arg.Priority,
		arg.BeadID,
		arg.Metadata,
		arg.SourceType,
		arg.SourceName,
		arg.Context,
	)
	return err
}

const deletePRFeedback = `-- name: DeletePRFeedback :exec
DELETE FROM pr_feedback WHERE id = ?
`

func (q *Queries) DeletePRFeedback(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deletePRFeedback, id)
	return err
}

const deletePRFeedbackForWork = `-- name: DeletePRFeedbackForWork :exec
DELETE FROM pr_feedback WHERE work_id = ?
`

func (q *Queries) DeletePRFeedbackForWork(ctx context.Context, workID string) error {
	_, err := q.db.ExecContext(ctx, deletePRFeedbackForWork, workID)
	return err
}

const getPRFeedback = `-- name: GetPRFeedback :one
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback WHERE id = ?
`

func (q *Queries) GetPRFeedback(ctx context.Context, id string) (PrFeedback, error) {
	row := q.db.QueryRowContext(ctx, getPRFeedback, id)
	var i PrFeedback
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.PrUrl,
		&i.FeedbackType,
		&i.Title,
		&i.Description,
		&i.Source,
		&i.SourceUrl,
		&i.SourceID,
		&i.SourceType,
		&i.SourceName,
		&i.Context,
		&i.Priority,
		&i.BeadID,
		&i.Metadata,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getPRFeedbackByBead = `-- name: GetPRFeedbackByBead :one
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback WHERE bead_id = ? LIMIT 1
`

func (q *Queries) GetPRFeedbackByBead(ctx context.Context, beadID sql.NullString) (PrFeedback, error) {
	row := q.db.QueryRowContext(ctx, getPRFeedbackByBead, beadID)
	var i PrFeedback
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.PrUrl,
		&i.FeedbackType,
		&i.Title,
		&i.Description,
		&i.Source,
		&i.SourceUrl,
		&i.SourceID,
		&i.SourceType,
		&i.SourceName,
		&i.Context,
		&i.Priority,
		&i.BeadID,
		&i.Metadata,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getPRFeedbackBySourceID = `-- name: GetPRFeedbackBySourceID :one
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback
WHERE work_id = ? AND source_id = ?
LIMIT 1
`

type GetPRFeedbackBySourceIDParams struct {
	WorkID   string         `json:"work_id"`
	SourceID sql.NullString `json:"source_id"`
}

func (q *Queries) GetPRFeedbackBySourceID(ctx context.Context, arg GetPRFeedbackBySourceIDParams) (PrFeedback, error) {
	row := q.db.QueryRowContext(ctx, getPRFeedbackBySourceID, arg.WorkID, arg.SourceID)
	var i PrFeedback
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.PrUrl,
		&i.FeedbackType,
		&i.Title,
		&i.Description,
		&i.Source,
		&i.SourceUrl,
		&i.SourceID,
		&i.SourceType,
		&i.SourceName,
		&i.Context,
		&i.Priority,
		&i.BeadID,
		&i.Metadata,
		&i.CreatedAt,
		&i.ProcessedAt,
		&i.ResolvedAt,
	)
	return i, err
}

const getUnassignedFeedbackBeadIDs = `-- name: GetUnassignedFeedbackBeadIDs :many
SELECT pf.bead_id FROM pr_feedback pf
WHERE pf.work_id = ?
  AND pf.bead_id IS NOT NULL
  AND pf.resolved_at IS NULL
  AND NOT EXISTS (
    SELECT 1 FROM task_beads tb
    JOIN tasks t ON tb.task_id = t.id
    WHERE tb.bead_id = pf.bead_id
      AND t.work_id = pf.work_id
  )
ORDER BY pf.created_at ASC
`

// Get bead IDs from PR feedback items that are not yet assigned to any task and not resolved/closed.
func (q *Queries) GetUnassignedFeedbackBeadIDs(ctx context.Context, workID string) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, getUnassignedFeedbackBeadIDs, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []sql.NullString{}
	for rows.Next() {
		var bead_id sql.NullString
		if err := rows.Scan(&bead_id); err != nil {
			return nil, err
		}
		items = append(items, bead_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnresolvedFeedbackForBeads = `-- name: GetUnresolvedFeedbackForBeads :many
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback
WHERE bead_id IN (/*SLICE:bead_ids*/?)
  AND resolved_at IS NULL
  AND source_id IS NOT NULL
ORDER BY created_at ASC
`

func (q *Queries) GetUnresolvedFeedbackForBeads(ctx context.Context, beadIds []sql.NullString) ([]PrFeedback, error) {
	query := getUnresolvedFeedbackForBeads
	var queryParams []interface{}
	if len(beadIds) > 0 {
		for _, v := range beadIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:bead_ids*/?", strings.Repeat(",?", len(beadIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:bead_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PrFeedback{}
	for rows.Next() {
		var i PrFeedback
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.PrUrl,
			&i.FeedbackType,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SourceUrl,
			&i.SourceID,
			&i.SourceType,
			&i.SourceName,
			&i.Context,
			&i.Priority,
			&i.BeadID,
			&i.Metadata,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnresolvedFeedbackForWork = `-- name: GetUnresolvedFeedbackForWork :many
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback
WHERE work_id = ?
  AND bead_id IS NOT NULL
  AND resolved_at IS NULL
  AND source_id IS NOT NULL
ORDER BY created_at ASC
`

func (q *Queries) GetUnresolvedFeedbackForWork(ctx context.Context, workID string) ([]PrFeedback, error) {
	rows, err := q.db.QueryContext(ctx, getUnresolvedFeedbackForWork, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PrFeedback{}
	for rows.Next() {
		var i PrFeedback
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.PrUrl,
			&i.FeedbackType,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SourceUrl,
			&i.SourceID,
			&i.SourceType,
			&i.SourceName,
			&i.Context,
			&i.Priority,
			&i.BeadID,
			&i.Metadata,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const hasExistingFeedback = `-- name: HasExistingFeedback :one
SELECT COUNT(*) as count FROM pr_feedback
WHERE work_id = ? AND title = ? AND source = ?
`

type HasExistingFeedbackParams struct {
	WorkID string `json:"work_id"`
	Title  string `json:"title"`
	Source string `json:"source"`
}

func (q *Queries) HasExistingFeedback(ctx context.Context, arg HasExistingFeedbackParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasExistingFeedback, arg.WorkID, arg.Title, arg.Source)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const hasExistingFeedbackBySourceID = `-- name: HasExistingFeedbackBySourceID :one
SELECT COUNT(*) as count FROM pr_feedback
WHERE work_id = ? AND source_id = ?
`

type HasExistingFeedbackBySourceIDParams struct {
	WorkID   string         `json:"work_id"`
	SourceID sql.NullString `json:"source_id"`
}

func (q *Queries) HasExistingFeedbackBySourceID(ctx context.Context, arg HasExistingFeedbackBySourceIDParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, hasExistingFeedbackBySourceID, arg.WorkID, arg.SourceID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listPRFeedback = `-- name: ListPRFeedback :many
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback WHERE work_id = ? ORDER BY created_at DESC
`

func (q *Queries) ListPRFeedback(ctx context.Context, workID string) ([]PrFeedback, error) {
	rows, err := q.db.QueryContext(ctx, listPRFeedback, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PrFeedback{}
	for rows.Next() {
		var i PrFeedback
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.PrUrl,
			&i.FeedbackType,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SourceUrl,
			&i.SourceID,
			&i.SourceType,
			&i.SourceName,
			&i.Context,
			&i.Priority,
			&i.BeadID,
			&i.Metadata,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnprocessedPRFeedback = `-- name: ListUnprocessedPRFeedback :many
SELECT id, work_id, pr_url, feedback_type, title, description, source, source_url, source_id, source_type, source_name, context, priority, bead_id, metadata, created_at, processed_at, resolved_at FROM pr_feedback
WHERE work_id = ? AND processed_at IS NULL
ORDER BY priority ASC, created_at ASC
`

func (q *Queries) ListUnprocessedPRFeedback(ctx context.Context, workID string) ([]PrFeedback, error) {
	rows, err := q.db.QueryContext(ctx, listUnprocessedPRFeedback, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PrFeedback{}
	for rows.Next() {
		var i PrFeedback
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.PrUrl,
			&i.FeedbackType,
			&i.Title,
			&i.Description,
			&i.Source,
			&i.SourceUrl,
			&i.SourceID,
			&i.SourceType,
			&i.SourceName,
			&i.Context,
			&i.Priority,
			&i.BeadID,
			&i.Metadata,
			&i.CreatedAt,
			&i.ProcessedAt,
			&i.ResolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markPRFeedbackProcessed = `-- name: MarkPRFeedbackProcessed :exec
UPDATE pr_feedback
SET processed_at = CURRENT_TIMESTAMP, bead_id = ?
WHERE id = ?
`

type MarkPRFeedbackProcessedParams struct {
	BeadID sql.NullString `json:"bead_id"`
	ID     string         `json:"id"`
}

func (q *Queries) MarkPRFeedbackProcessed(ctx context.Context, arg MarkPRFeedbackProcessedParams) error {
	_, err := q.db.ExecContext(ctx, markPRFeedbackProcessed, arg.BeadID, arg.ID)
	return err
}

const markPRFeedbackResolved = `-- name: MarkPRFeedbackResolved :exec
UPDATE pr_feedback
SET resolved_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkPRFeedbackResolved(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markPRFeedbackResolved, id)
	return err
}
