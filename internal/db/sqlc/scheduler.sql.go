// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: scheduler.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countPendingTasksForWork = `-- name: CountPendingTasksForWork :one
SELECT COUNT(*) as count FROM scheduler
WHERE work_id = ?
  AND status = 'pending'
`

func (q *Queries) CountPendingTasksForWork(ctx context.Context, workID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countPendingTasksForWork, workID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createScheduledTask = `-- name: CreateScheduledTask :exec
INSERT INTO scheduler (
    id, work_id, task_type, scheduled_at, status, metadata
) VALUES (?, ?, ?, ?, ?, ?)
`

type CreateScheduledTaskParams struct {
	ID          string    `json:"id"`
	WorkID      string    `json:"work_id"`
	TaskType    string    `json:"task_type"`
	ScheduledAt time.Time `json:"scheduled_at"`
	Status      string    `json:"status"`
	Metadata    string    `json:"metadata"`
}

func (q *Queries) CreateScheduledTask(ctx context.Context, arg CreateScheduledTaskParams) error {
	_, err := q.db.ExecContext(ctx, createScheduledTask,
		arg.ID,
		arg.WorkID,
		arg.TaskType,
		arg.ScheduledAt,
		arg.Status,
		arg.Metadata,
	)
	return err
}

const createScheduledTaskWithRetry = `-- name: CreateScheduledTaskWithRetry :exec
INSERT INTO scheduler (
    id, work_id, task_type, scheduled_at, status, metadata, attempt_count, max_attempts, idempotency_key
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateScheduledTaskWithRetryParams struct {
	ID             string         `json:"id"`
	WorkID         string         `json:"work_id"`
	TaskType       string         `json:"task_type"`
	ScheduledAt    time.Time      `json:"scheduled_at"`
	Status         string         `json:"status"`
	Metadata       string         `json:"metadata"`
	AttemptCount   int64          `json:"attempt_count"`
	MaxAttempts    int64          `json:"max_attempts"`
	IdempotencyKey sql.NullString `json:"idempotency_key"`
}

func (q *Queries) CreateScheduledTaskWithRetry(ctx context.Context, arg CreateScheduledTaskWithRetryParams) error {
	_, err := q.db.ExecContext(ctx, createScheduledTaskWithRetry,
		arg.ID,
		arg.WorkID,
		arg.TaskType,
		arg.ScheduledAt,
		arg.Status,
		arg.Metadata,
		arg.AttemptCount,
		arg.MaxAttempts,
		arg.IdempotencyKey,
	)
	return err
}

const deleteCompletedTasksOlderThan = `-- name: DeleteCompletedTasksOlderThan :exec
DELETE FROM scheduler
WHERE status IN ('completed', 'failed')
  AND executed_at < ?
`

func (q *Queries) DeleteCompletedTasksOlderThan(ctx context.Context, executedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedTasksOlderThan, executedAt)
	return err
}

const deleteScheduledTask = `-- name: DeleteScheduledTask :exec
DELETE FROM scheduler WHERE id = ?
`

func (q *Queries) DeleteScheduledTask(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteScheduledTask, id)
	return err
}

const getNextScheduledTask = `-- name: GetNextScheduledTask :one
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE status = 'pending'
  AND datetime(scheduled_at) <= datetime('now')
ORDER BY scheduled_at ASC
LIMIT 1
`

func (q *Queries) GetNextScheduledTask(ctx context.Context) (Scheduler, error) {
	row := q.db.QueryRowContext(ctx, getNextScheduledTask)
	var i Scheduler
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.TaskType,
		&i.ScheduledAt,
		&i.ExecutedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.Metadata,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOverdueTasks = `-- name: GetOverdueTasks :many
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE status = 'pending'
  AND datetime(scheduled_at) < datetime('now', '-10 minutes')
ORDER BY scheduled_at ASC
`

func (q *Queries) GetOverdueTasks(ctx context.Context) ([]Scheduler, error) {
	rows, err := q.db.QueryContext(ctx, getOverdueTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scheduler{}
	for rows.Next() {
		var i Scheduler
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.TaskType,
			&i.ScheduledAt,
			&i.ExecutedAt,
			&i.Status,
			&i.ErrorMessage,
			&i.Metadata,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.IdempotencyKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingTaskByType = `-- name: GetPendingTaskByType :one
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE work_id = ?
  AND task_type = ?
  AND status = 'pending'
ORDER BY scheduled_at ASC
LIMIT 1
`

type GetPendingTaskByTypeParams struct {
	WorkID   string `json:"work_id"`
	TaskType string `json:"task_type"`
}

func (q *Queries) GetPendingTaskByType(ctx context.Context, arg GetPendingTaskByTypeParams) (Scheduler, error) {
	row := q.db.QueryRowContext(ctx, getPendingTaskByType, arg.WorkID, arg.TaskType)
	var i Scheduler
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.TaskType,
		&i.ScheduledAt,
		&i.ExecutedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.Metadata,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduledTaskByID = `-- name: GetScheduledTaskByID :one
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler WHERE id = ?
`

func (q *Queries) GetScheduledTaskByID(ctx context.Context, id string) (Scheduler, error) {
	row := q.db.QueryRowContext(ctx, getScheduledTaskByID, id)
	var i Scheduler
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.TaskType,
		&i.ScheduledAt,
		&i.ExecutedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.Metadata,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getScheduledTasksForWork = `-- name: GetScheduledTasksForWork :many
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE work_id = ?
  AND status = 'pending'
  AND datetime(scheduled_at) <= datetime('now')
ORDER BY scheduled_at ASC
`

func (q *Queries) GetScheduledTasksForWork(ctx context.Context, workID string) ([]Scheduler, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledTasksForWork, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scheduler{}
	for rows.Next() {
		var i Scheduler
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.TaskType,
			&i.ScheduledAt,
			&i.ExecutedAt,
			&i.Status,
			&i.ErrorMessage,
			&i.Metadata,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.IdempotencyKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByIdempotencyKey = `-- name: GetTaskByIdempotencyKey :one
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE idempotency_key = ?
LIMIT 1
`

func (q *Queries) GetTaskByIdempotencyKey(ctx context.Context, idempotencyKey sql.NullString) (Scheduler, error) {
	row := q.db.QueryRowContext(ctx, getTaskByIdempotencyKey, idempotencyKey)
	var i Scheduler
	err := row.Scan(
		&i.ID,
		&i.WorkID,
		&i.TaskType,
		&i.ScheduledAt,
		&i.ExecutedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.Metadata,
		&i.AttemptCount,
		&i.MaxAttempts,
		&i.IdempotencyKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementAttemptAndReschedule = `-- name: IncrementAttemptAndReschedule :exec
UPDATE scheduler
SET attempt_count = attempt_count + 1,
    scheduled_at = ?,
    status = 'pending',
    error_message = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type IncrementAttemptAndRescheduleParams struct {
	ScheduledAt  time.Time      `json:"scheduled_at"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) IncrementAttemptAndReschedule(ctx context.Context, arg IncrementAttemptAndRescheduleParams) error {
	_, err := q.db.ExecContext(ctx, incrementAttemptAndReschedule, arg.ScheduledAt, arg.ErrorMessage, arg.ID)
	return err
}

const markTaskCompleted = `-- name: MarkTaskCompleted :exec
UPDATE scheduler
SET status = 'completed',
    executed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkTaskCompleted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markTaskCompleted, id)
	return err
}

const markTaskCompletedByIdempotencyKey = `-- name: MarkTaskCompletedByIdempotencyKey :exec
UPDATE scheduler
SET status = 'completed',
    executed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE idempotency_key = ?
`

func (q *Queries) MarkTaskCompletedByIdempotencyKey(ctx context.Context, idempotencyKey sql.NullString) error {
	_, err := q.db.ExecContext(ctx, markTaskCompletedByIdempotencyKey, idempotencyKey)
	return err
}

const markTaskExecuting = `-- name: MarkTaskExecuting :exec
UPDATE scheduler
SET status = 'executing',
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) MarkTaskExecuting(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markTaskExecuting, id)
	return err
}

const markTaskFailed = `-- name: MarkTaskFailed :exec
UPDATE scheduler
SET status = 'failed',
    error_message = ?,
    executed_at = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type MarkTaskFailedParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) MarkTaskFailed(ctx context.Context, arg MarkTaskFailedParams) error {
	_, err := q.db.ExecContext(ctx, markTaskFailed, arg.ErrorMessage, arg.ID)
	return err
}

const rescheduleTask = `-- name: RescheduleTask :exec
UPDATE scheduler
SET scheduled_at = ?,
    status = 'pending',
    error_message = NULL,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type RescheduleTaskParams struct {
	ScheduledAt time.Time `json:"scheduled_at"`
	ID          string    `json:"id"`
}

func (q *Queries) RescheduleTask(ctx context.Context, arg RescheduleTaskParams) error {
	_, err := q.db.ExecContext(ctx, rescheduleTask, arg.ScheduledAt, arg.ID)
	return err
}

const updateScheduledTaskTime = `-- name: UpdateScheduledTaskTime :exec
UPDATE scheduler
SET scheduled_at = ?,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateScheduledTaskTimeParams struct {
	ScheduledAt time.Time `json:"scheduled_at"`
	ID          string    `json:"id"`
}

func (q *Queries) UpdateScheduledTaskTime(ctx context.Context, arg UpdateScheduledTaskTimeParams) error {
	_, err := q.db.ExecContext(ctx, updateScheduledTaskTime, arg.ScheduledAt, arg.ID)
	return err
}

const watchSchedulerChanges = `-- name: WatchSchedulerChanges :many
SELECT id, work_id, task_type, scheduled_at, executed_at, status, error_message, metadata, attempt_count, max_attempts, idempotency_key, created_at, updated_at FROM scheduler
WHERE updated_at > ?
ORDER BY updated_at ASC
`

func (q *Queries) WatchSchedulerChanges(ctx context.Context, updatedAt time.Time) ([]Scheduler, error) {
	rows, err := q.db.QueryContext(ctx, watchSchedulerChanges, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Scheduler{}
	for rows.Next() {
		var i Scheduler
		if err := rows.Scan(
			&i.ID,
			&i.WorkID,
			&i.TaskType,
			&i.ScheduledAt,
			&i.ExecutedAt,
			&i.Status,
			&i.ErrorMessage,
			&i.Metadata,
			&i.AttemptCount,
			&i.MaxAttempts,
			&i.IdempotencyKey,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
