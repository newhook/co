// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: beads.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const completeBead = `-- name: CompleteBead :execrows
UPDATE beads
SET status = 'completed',
    pr_url = ?,
    completed_at = ?,
    updated_at = ?
WHERE id = ?
`

type CompleteBeadParams struct {
	PrUrl       string       `json:"pr_url"`
	CompletedAt sql.NullTime `json:"completed_at"`
	UpdatedAt   time.Time    `json:"updated_at"`
	ID          string       `json:"id"`
}

func (q *Queries) CompleteBead(ctx context.Context, arg CompleteBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeBead,
		arg.PrUrl,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failBead = `-- name: FailBead :execrows
UPDATE beads
SET status = 'failed',
    error_message = ?,
    completed_at = ?,
    updated_at = ?
WHERE id = ?
`

type FailBeadParams struct {
	ErrorMessage string       `json:"error_message"`
	CompletedAt  sql.NullTime `json:"completed_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	ID           string       `json:"id"`
}

func (q *Queries) FailBead(ctx context.Context, arg FailBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failBead,
		arg.ErrorMessage,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBead = `-- name: GetBead :one
SELECT id, status, title, pr_url, error_message, zellij_session, zellij_pane,
       worktree_path, started_at, completed_at, created_at, updated_at
FROM beads
WHERE id = ?
`

func (q *Queries) GetBead(ctx context.Context, id string) (Bead, error) {
	row := q.db.QueryRowContext(ctx, getBead, id)
	var i Bead
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.Title,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.ZellijSession,
		&i.ZellijPane,
		&i.WorktreePath,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getBeadStatus = `-- name: GetBeadStatus :one
SELECT status
FROM beads
WHERE id = ?
`

func (q *Queries) GetBeadStatus(ctx context.Context, id string) (string, error) {
	row := q.db.QueryRowContext(ctx, getBeadStatus, id)
	var status string
	err := row.Scan(&status)
	return status, err
}

const listBeads = `-- name: ListBeads :many
SELECT id, status, title, pr_url, error_message, zellij_session, zellij_pane,
       worktree_path, started_at, completed_at, created_at, updated_at
FROM beads
ORDER BY created_at DESC
`

func (q *Queries) ListBeads(ctx context.Context) ([]Bead, error) {
	rows, err := q.db.QueryContext(ctx, listBeads)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bead{}
	for rows.Next() {
		var i Bead
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Title,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.ZellijSession,
			&i.ZellijPane,
			&i.WorktreePath,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBeadsByStatus = `-- name: ListBeadsByStatus :many
SELECT id, status, title, pr_url, error_message, zellij_session, zellij_pane,
       worktree_path, started_at, completed_at, created_at, updated_at
FROM beads
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListBeadsByStatus(ctx context.Context, status string) ([]Bead, error) {
	rows, err := q.db.QueryContext(ctx, listBeadsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Bead{}
	for rows.Next() {
		var i Bead
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Title,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.ZellijSession,
			&i.ZellijPane,
			&i.WorktreePath,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const startBead = `-- name: StartBead :exec
INSERT INTO beads (id, status, title, zellij_session, zellij_pane, worktree_path, started_at, updated_at)
VALUES (?, 'processing', ?, ?, ?, ?, ?, ?)
ON CONFLICT(id) DO UPDATE SET
    status = 'processing',
    title = excluded.title,
    zellij_session = excluded.zellij_session,
    zellij_pane = excluded.zellij_pane,
    worktree_path = excluded.worktree_path,
    started_at = excluded.started_at,
    updated_at = excluded.updated_at
`

type StartBeadParams struct {
	ID            string       `json:"id"`
	Title         string       `json:"title"`
	ZellijSession string       `json:"zellij_session"`
	ZellijPane    string       `json:"zellij_pane"`
	WorktreePath  string       `json:"worktree_path"`
	StartedAt     sql.NullTime `json:"started_at"`
	UpdatedAt     time.Time    `json:"updated_at"`
}

func (q *Queries) StartBead(ctx context.Context, arg StartBeadParams) error {
	_, err := q.db.ExecContext(ctx, startBead,
		arg.ID,
		arg.Title,
		arg.ZellijSession,
		arg.ZellijPane,
		arg.WorktreePath,
		arg.StartedAt,
		arg.UpdatedAt,
	)
	return err
}
