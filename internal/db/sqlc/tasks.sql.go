// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tasks.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const completeTask = `-- name: CompleteTask :execrows
UPDATE tasks
SET status = 'completed',
    pr_url = ?,
    completed_at = ?
WHERE id = ?
`

type CompleteTaskParams struct {
	PrUrl       string       `json:"pr_url"`
	CompletedAt sql.NullTime `json:"completed_at"`
	ID          string       `json:"id"`
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeTask, arg.PrUrl, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const completeTaskBead = `-- name: CompleteTaskBead :execrows
UPDATE task_beads
SET status = 'completed'
WHERE task_id = ? AND bead_id = ?
`

type CompleteTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) CompleteTaskBead(ctx context.Context, arg CompleteTaskBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeTaskBead, arg.TaskID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countTaskBeadStatuses = `-- name: CountTaskBeadStatuses :one
SELECT COUNT(*) as total,
       COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed
FROM task_beads
WHERE task_id = ?
`

type CountTaskBeadStatusesRow struct {
	Total     int64 `json:"total"`
	Completed int64 `json:"completed"`
}

func (q *Queries) CountTaskBeadStatuses(ctx context.Context, taskID string) (CountTaskBeadStatusesRow, error) {
	row := q.db.QueryRowContext(ctx, countTaskBeadStatuses, taskID)
	var i CountTaskBeadStatusesRow
	err := row.Scan(&i.Total, &i.Completed)
	return i, err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO tasks (id, status, task_type, complexity_budget, work_id)
VALUES (?, 'pending', ?, ?, ?)
`

type CreateTaskParams struct {
	ID               string `json:"id"`
	TaskType         string `json:"task_type"`
	ComplexityBudget int64  `json:"complexity_budget"`
	WorkID           string `json:"work_id"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask,
		arg.ID,
		arg.TaskType,
		arg.ComplexityBudget,
		arg.WorkID,
	)
	return err
}

const createTaskBead = `-- name: CreateTaskBead :exec
INSERT INTO task_beads (task_id, bead_id, status)
VALUES (?, ?, 'pending')
`

type CreateTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) CreateTaskBead(ctx context.Context, arg CreateTaskBeadParams) error {
	_, err := q.db.ExecContext(ctx, createTaskBead, arg.TaskID, arg.BeadID)
	return err
}

const deleteTask = `-- name: DeleteTask :execrows
DELETE FROM tasks
WHERE id = ?
`

func (q *Queries) DeleteTask(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTask, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTaskBeadsByTask = `-- name: DeleteTaskBeadsByTask :execrows
DELETE FROM task_beads
WHERE task_id = ?
`

func (q *Queries) DeleteTaskBeadsByTask(ctx context.Context, taskID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTaskBeadsByTask, taskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTaskBeadsForWork = `-- name: DeleteTaskBeadsForWork :execrows
DELETE FROM task_beads
WHERE task_id IN (
    SELECT task_id FROM work_tasks WHERE work_id = ?
)
`

func (q *Queries) DeleteTaskBeadsForWork(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTaskBeadsForWork, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTasksForWork = `-- name: DeleteTasksForWork :execrows
DELETE FROM tasks
WHERE work_id = ?
`

func (q *Queries) DeleteTasksForWork(ctx context.Context, workID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTasksForWork, workID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteWorkTaskByTask = `-- name: DeleteWorkTaskByTask :execrows
DELETE FROM work_tasks
WHERE task_id = ?
`

func (q *Queries) DeleteWorkTaskByTask(ctx context.Context, taskID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteWorkTaskByTask, taskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failTask = `-- name: FailTask :execrows
UPDATE tasks
SET status = 'failed',
    error_message = ?,
    completed_at = ?
WHERE id = ?
`

type FailTaskParams struct {
	ErrorMessage string       `json:"error_message"`
	CompletedAt  sql.NullTime `json:"completed_at"`
	ID           string       `json:"id"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failTask, arg.ErrorMessage, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failTaskBead = `-- name: FailTaskBead :execrows
UPDATE task_beads
SET status = 'failed'
WHERE task_id = ? AND bead_id = ?
`

type FailTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) FailTaskBead(ctx context.Context, arg FailTaskBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failTaskBead, arg.TaskID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getTask = `-- name: GetTask :one
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       work_id,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       spawned_at,
       spawn_status
FROM tasks
WHERE id = ?
`

type GetTaskRow struct {
	ID               string       `json:"id"`
	Status           string       `json:"status"`
	TaskType         string       `json:"task_type"`
	ComplexityBudget int64        `json:"complexity_budget"`
	ActualComplexity int64        `json:"actual_complexity"`
	WorkID           string       `json:"work_id"`
	WorktreePath     string       `json:"worktree_path"`
	PrUrl            string       `json:"pr_url"`
	ErrorMessage     string       `json:"error_message"`
	StartedAt        sql.NullTime `json:"started_at"`
	CompletedAt      sql.NullTime `json:"completed_at"`
	CreatedAt        time.Time    `json:"created_at"`
	SpawnedAt        sql.NullTime `json:"spawned_at"`
	SpawnStatus      string       `json:"spawn_status"`
}

func (q *Queries) GetTask(ctx context.Context, id string) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.TaskType,
		&i.ComplexityBudget,
		&i.ActualComplexity,
		&i.WorkID,
		&i.WorktreePath,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.SpawnedAt,
		&i.SpawnStatus,
	)
	return i, err
}

const getTaskBeadStatus = `-- name: GetTaskBeadStatus :one
SELECT status
FROM task_beads
WHERE task_id = ? AND bead_id = ?
`

type GetTaskBeadStatusParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) GetTaskBeadStatus(ctx context.Context, arg GetTaskBeadStatusParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getTaskBeadStatus, arg.TaskID, arg.BeadID)
	var status string
	err := row.Scan(&status)
	return status, err
}

const getTaskBeads = `-- name: GetTaskBeads :many
SELECT bead_id
FROM task_beads
WHERE task_id = ?
`

func (q *Queries) GetTaskBeads(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskBeads, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var bead_id string
		if err := rows.Scan(&bead_id); err != nil {
			return nil, err
		}
		items = append(items, bead_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskBeadsForWork = `-- name: GetTaskBeadsForWork :many
SELECT tb.task_id, tb.bead_id, tb.status
FROM task_beads tb
JOIN tasks t ON tb.task_id = t.id
WHERE t.work_id = ?
`

func (q *Queries) GetTaskBeadsForWork(ctx context.Context, workID string) ([]TaskBead, error) {
	rows, err := q.db.QueryContext(ctx, getTaskBeadsForWork, workID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskBead{}
	for rows.Next() {
		var i TaskBead
		if err := rows.Scan(&i.TaskID, &i.BeadID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskBeadsWithStatus = `-- name: GetTaskBeadsWithStatus :many
SELECT task_id, bead_id, status
FROM task_beads
WHERE task_id = ?
`

func (q *Queries) GetTaskBeadsWithStatus(ctx context.Context, taskID string) ([]TaskBead, error) {
	rows, err := q.db.QueryContext(ctx, getTaskBeadsWithStatus, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskBead{}
	for rows.Next() {
		var i TaskBead
		if err := rows.Scan(&i.TaskID, &i.BeadID, &i.Status); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskForBead = `-- name: GetTaskForBead :one
SELECT task_id
FROM task_beads
WHERE bead_id = ?
`

func (q *Queries) GetTaskForBead(ctx context.Context, beadID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTaskForBead, beadID)
	var task_id string
	err := row.Scan(&task_id)
	return task_id, err
}

const getTasksWithActivity = `-- name: GetTasksWithActivity :many
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       work_id,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       spawned_at,
       spawn_status,
       last_activity
FROM tasks
WHERE status = 'processing'
ORDER BY last_activity DESC
`

func (q *Queries) GetTasksWithActivity(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, getTasksWithActivity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
			&i.LastActivity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       work_id,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       spawned_at,
       spawn_status
FROM tasks
ORDER BY created_at DESC
`

type ListTasksRow struct {
	ID               string       `json:"id"`
	Status           string       `json:"status"`
	TaskType         string       `json:"task_type"`
	ComplexityBudget int64        `json:"complexity_budget"`
	ActualComplexity int64        `json:"actual_complexity"`
	WorkID           string       `json:"work_id"`
	WorktreePath     string       `json:"worktree_path"`
	PrUrl            string       `json:"pr_url"`
	ErrorMessage     string       `json:"error_message"`
	StartedAt        sql.NullTime `json:"started_at"`
	CompletedAt      sql.NullTime `json:"completed_at"`
	CreatedAt        time.Time    `json:"created_at"`
	SpawnedAt        sql.NullTime `json:"spawned_at"`
	SpawnStatus      string       `json:"spawn_status"`
}

func (q *Queries) ListTasks(ctx context.Context) ([]ListTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksRow{}
	for rows.Next() {
		var i ListTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByStatus = `-- name: ListTasksByStatus :many
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       work_id,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at,
       spawned_at,
       spawn_status
FROM tasks
WHERE status = ?
ORDER BY created_at DESC
`

type ListTasksByStatusRow struct {
	ID               string       `json:"id"`
	Status           string       `json:"status"`
	TaskType         string       `json:"task_type"`
	ComplexityBudget int64        `json:"complexity_budget"`
	ActualComplexity int64        `json:"actual_complexity"`
	WorkID           string       `json:"work_id"`
	WorktreePath     string       `json:"worktree_path"`
	PrUrl            string       `json:"pr_url"`
	ErrorMessage     string       `json:"error_message"`
	StartedAt        sql.NullTime `json:"started_at"`
	CompletedAt      sql.NullTime `json:"completed_at"`
	CreatedAt        time.Time    `json:"created_at"`
	SpawnedAt        sql.NullTime `json:"spawned_at"`
	SpawnStatus      string       `json:"spawn_status"`
}

func (q *Queries) ListTasksByStatus(ctx context.Context, status string) ([]ListTasksByStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksByStatusRow{}
	for rows.Next() {
		var i ListTasksByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.WorkID,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.SpawnedAt,
			&i.SpawnStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetTaskBeadStatus = `-- name: ResetTaskBeadStatus :execrows
UPDATE task_beads
SET status = 'pending'
WHERE task_id = ? AND bead_id = ?
`

type ResetTaskBeadStatusParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) ResetTaskBeadStatus(ctx context.Context, arg ResetTaskBeadStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetTaskBeadStatus, arg.TaskID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetTaskBeadStatuses = `-- name: ResetTaskBeadStatuses :execrows
UPDATE task_beads
SET status = 'pending'
WHERE task_id = ?
`

func (q *Queries) ResetTaskBeadStatuses(ctx context.Context, taskID string) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetTaskBeadStatuses, taskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const resetTaskStatus = `-- name: ResetTaskStatus :execrows
UPDATE tasks
SET status = 'pending',
    started_at = NULL,
    error_message = ''
WHERE id = ?
`

func (q *Queries) ResetTaskStatus(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetTaskStatus, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const spawnTask = `-- name: SpawnTask :execrows
UPDATE tasks
SET spawned_at = ?,
    spawn_status = ?
WHERE id = ?
`

type SpawnTaskParams struct {
	SpawnedAt   sql.NullTime `json:"spawned_at"`
	SpawnStatus string       `json:"spawn_status"`
	ID          string       `json:"id"`
}

func (q *Queries) SpawnTask(ctx context.Context, arg SpawnTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, spawnTask, arg.SpawnedAt, arg.SpawnStatus, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const startTask = `-- name: StartTask :execrows
UPDATE tasks
SET status = 'processing',
    worktree_path = ?,
    started_at = ?
WHERE id = ?
`

type StartTaskParams struct {
	WorktreePath string       `json:"worktree_path"`
	StartedAt    sql.NullTime `json:"started_at"`
	ID           string       `json:"id"`
}

func (q *Queries) StartTask(ctx context.Context, arg StartTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, startTask, arg.WorktreePath, arg.StartedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTaskActivity = `-- name: UpdateTaskActivity :execrows
UPDATE tasks
SET last_activity = ?
WHERE id = ? AND status = 'processing'
`

type UpdateTaskActivityParams struct {
	LastActivity sql.NullTime `json:"last_activity"`
	ID           string       `json:"id"`
}

func (q *Queries) UpdateTaskActivity(ctx context.Context, arg UpdateTaskActivityParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTaskActivity, arg.LastActivity, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
