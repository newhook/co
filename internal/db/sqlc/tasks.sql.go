// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: tasks.sql

package sqlc

import (
	"context"
	"database/sql"
)

const completeTask = `-- name: CompleteTask :execrows
UPDATE tasks
SET status = 'completed',
    pr_url = ?,
    completed_at = ?
WHERE id = ?
`

type CompleteTaskParams struct {
	PrUrl       sql.NullString `json:"pr_url"`
	CompletedAt sql.NullTime   `json:"completed_at"`
	ID          string         `json:"id"`
}

func (q *Queries) CompleteTask(ctx context.Context, arg CompleteTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeTask, arg.PrUrl, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const completeTaskBead = `-- name: CompleteTaskBead :execrows
UPDATE task_beads
SET status = 'completed'
WHERE task_id = ? AND bead_id = ?
`

type CompleteTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) CompleteTaskBead(ctx context.Context, arg CompleteTaskBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeTaskBead, arg.TaskID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const countTaskBeadStatuses = `-- name: CountTaskBeadStatuses :one
SELECT COUNT(*) as total,
       COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed
FROM task_beads
WHERE task_id = ?
`

type CountTaskBeadStatusesRow struct {
	Total     int64 `json:"total"`
	Completed int64 `json:"completed"`
}

func (q *Queries) CountTaskBeadStatuses(ctx context.Context, taskID string) (CountTaskBeadStatusesRow, error) {
	row := q.db.QueryRowContext(ctx, countTaskBeadStatuses, taskID)
	var i CountTaskBeadStatusesRow
	err := row.Scan(&i.Total, &i.Completed)
	return i, err
}

const createTask = `-- name: CreateTask :exec
INSERT INTO tasks (id, status, task_type, complexity_budget)
VALUES (?, 'pending', ?, ?)
`

type CreateTaskParams struct {
	ID               string        `json:"id"`
	TaskType         string        `json:"task_type"`
	ComplexityBudget sql.NullInt64 `json:"complexity_budget"`
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.ExecContext(ctx, createTask, arg.ID, arg.TaskType, arg.ComplexityBudget)
	return err
}

const createTaskBead = `-- name: CreateTaskBead :exec
INSERT INTO task_beads (task_id, bead_id, status)
VALUES (?, ?, 'pending')
`

type CreateTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) CreateTaskBead(ctx context.Context, arg CreateTaskBeadParams) error {
	_, err := q.db.ExecContext(ctx, createTaskBead, arg.TaskID, arg.BeadID)
	return err
}

const failTask = `-- name: FailTask :execrows
UPDATE tasks
SET status = 'failed',
    error_message = ?,
    completed_at = ?
WHERE id = ?
`

type FailTaskParams struct {
	ErrorMessage sql.NullString `json:"error_message"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           string         `json:"id"`
}

func (q *Queries) FailTask(ctx context.Context, arg FailTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failTask, arg.ErrorMessage, arg.CompletedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const failTaskBead = `-- name: FailTaskBead :execrows
UPDATE task_beads
SET status = 'failed'
WHERE task_id = ? AND bead_id = ?
`

type FailTaskBeadParams struct {
	TaskID string `json:"task_id"`
	BeadID string `json:"bead_id"`
}

func (q *Queries) FailTaskBead(ctx context.Context, arg FailTaskBeadParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failTaskBead, arg.TaskID, arg.BeadID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getTask = `-- name: GetTask :one
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       zellij_session,
       zellij_pane,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM tasks
WHERE id = ?
`

func (q *Queries) GetTask(ctx context.Context, id string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.TaskType,
		&i.ComplexityBudget,
		&i.ActualComplexity,
		&i.ZellijSession,
		&i.ZellijPane,
		&i.WorktreePath,
		&i.PrUrl,
		&i.ErrorMessage,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getTaskBeads = `-- name: GetTaskBeads :many
SELECT bead_id
FROM task_beads
WHERE task_id = ?
`

func (q *Queries) GetTaskBeads(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getTaskBeads, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var bead_id string
		if err := rows.Scan(&bead_id); err != nil {
			return nil, err
		}
		items = append(items, bead_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskForBead = `-- name: GetTaskForBead :one
SELECT task_id
FROM task_beads
WHERE bead_id = ?
`

func (q *Queries) GetTaskForBead(ctx context.Context, beadID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getTaskForBead, beadID)
	var task_id string
	err := row.Scan(&task_id)
	return task_id, err
}

const listTasks = `-- name: ListTasks :many
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       zellij_session,
       zellij_pane,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM tasks
ORDER BY created_at DESC
`

func (q *Queries) ListTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.ZellijSession,
			&i.ZellijPane,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksByStatus = `-- name: ListTasksByStatus :many
SELECT id, status,
       COALESCE(task_type, 'implement') as task_type,
       complexity_budget,
       actual_complexity,
       zellij_session,
       zellij_pane,
       worktree_path,
       pr_url,
       error_message,
       started_at,
       completed_at,
       created_at
FROM tasks
WHERE status = ?
ORDER BY created_at DESC
`

func (q *Queries) ListTasksByStatus(ctx context.Context, status string) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listTasksByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Task{}
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TaskType,
			&i.ComplexityBudget,
			&i.ActualComplexity,
			&i.ZellijSession,
			&i.ZellijPane,
			&i.WorktreePath,
			&i.PrUrl,
			&i.ErrorMessage,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetTaskStatus = `-- name: ResetTaskStatus :execrows
UPDATE tasks
SET status = 'pending',
    zellij_session = NULL,
    zellij_pane = NULL,
    started_at = NULL,
    error_message = NULL
WHERE id = ?
`

func (q *Queries) ResetTaskStatus(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, resetTaskStatus, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const startTask = `-- name: StartTask :execrows
UPDATE tasks
SET status = 'processing',
    zellij_session = ?,
    zellij_pane = ?,
    worktree_path = ?,
    started_at = ?
WHERE id = ?
`

type StartTaskParams struct {
	ZellijSession sql.NullString `json:"zellij_session"`
	ZellijPane    sql.NullString `json:"zellij_pane"`
	WorktreePath  sql.NullString `json:"worktree_path"`
	StartedAt     sql.NullTime   `json:"started_at"`
	ID            string         `json:"id"`
}

func (q *Queries) StartTask(ctx context.Context, arg StartTaskParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, startTask,
		arg.ZellijSession,
		arg.ZellijPane,
		arg.WorktreePath,
		arg.StartedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
