// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: processes.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteProcess = `-- name: DeleteProcess :exec
DELETE FROM processes WHERE id = ?
`

func (q *Queries) DeleteProcess(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProcess, id)
	return err
}

const deleteStaleProcesses = `-- name: DeleteStaleProcesses :exec
DELETE FROM processes
WHERE datetime(heartbeat) < datetime('now', ? || ' seconds')
`

func (q *Queries) DeleteStaleProcesses(ctx context.Context, dollar_1 sql.NullString) error {
	_, err := q.db.ExecContext(ctx, deleteStaleProcesses, dollar_1)
	return err
}

const getAllProcesses = `-- name: GetAllProcesses :many
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes ORDER BY started_at DESC
`

func (q *Queries) GetAllProcesses(ctx context.Context) ([]Process, error) {
	rows, err := q.db.QueryContext(ctx, getAllProcesses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Process{}
	for rows.Next() {
		var i Process
		if err := rows.Scan(
			&i.ID,
			&i.ProcessType,
			&i.WorkID,
			&i.Pid,
			&i.Hostname,
			&i.Heartbeat,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getControlPlaneProcess = `-- name: GetControlPlaneProcess :one
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes
WHERE process_type = 'control_plane'
LIMIT 1
`

func (q *Queries) GetControlPlaneProcess(ctx context.Context) (Process, error) {
	row := q.db.QueryRowContext(ctx, getControlPlaneProcess)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.ProcessType,
		&i.WorkID,
		&i.Pid,
		&i.Hostname,
		&i.Heartbeat,
		&i.StartedAt,
	)
	return i, err
}

const getOrchestratorProcess = `-- name: GetOrchestratorProcess :one
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes
WHERE work_id = ? AND process_type = 'orchestrator'
LIMIT 1
`

func (q *Queries) GetOrchestratorProcess(ctx context.Context, workID sql.NullString) (Process, error) {
	row := q.db.QueryRowContext(ctx, getOrchestratorProcess, workID)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.ProcessType,
		&i.WorkID,
		&i.Pid,
		&i.Hostname,
		&i.Heartbeat,
		&i.StartedAt,
	)
	return i, err
}

const getProcess = `-- name: GetProcess :one
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes WHERE id = ?
`

func (q *Queries) GetProcess(ctx context.Context, id string) (Process, error) {
	row := q.db.QueryRowContext(ctx, getProcess, id)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.ProcessType,
		&i.WorkID,
		&i.Pid,
		&i.Hostname,
		&i.Heartbeat,
		&i.StartedAt,
	)
	return i, err
}

const getProcessByWorkID = `-- name: GetProcessByWorkID :one
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes
WHERE work_id = ? AND process_type = 'orchestrator'
LIMIT 1
`

func (q *Queries) GetProcessByWorkID(ctx context.Context, workID sql.NullString) (Process, error) {
	row := q.db.QueryRowContext(ctx, getProcessByWorkID, workID)
	var i Process
	err := row.Scan(
		&i.ID,
		&i.ProcessType,
		&i.WorkID,
		&i.Pid,
		&i.Hostname,
		&i.Heartbeat,
		&i.StartedAt,
	)
	return i, err
}

const getStaleProcesses = `-- name: GetStaleProcesses :many
SELECT id, process_type, work_id, pid, hostname, heartbeat, started_at FROM processes
WHERE datetime(heartbeat) < datetime('now', ? || ' seconds')
`

func (q *Queries) GetStaleProcesses(ctx context.Context, dollar_1 sql.NullString) ([]Process, error) {
	rows, err := q.db.QueryContext(ctx, getStaleProcesses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Process{}
	for rows.Next() {
		var i Process
		if err := rows.Scan(
			&i.ID,
			&i.ProcessType,
			&i.WorkID,
			&i.Pid,
			&i.Hostname,
			&i.Heartbeat,
			&i.StartedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isControlPlaneAlive = `-- name: IsControlPlaneAlive :one
SELECT EXISTS(
    SELECT 1 FROM processes
    WHERE process_type = 'control_plane'
      AND datetime(heartbeat) >= datetime('now', ? || ' seconds')
) as alive
`

func (q *Queries) IsControlPlaneAlive(ctx context.Context, dollar_1 sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, isControlPlaneAlive, dollar_1)
	var alive int64
	err := row.Scan(&alive)
	return alive, err
}

const isOrchestratorAlive = `-- name: IsOrchestratorAlive :one
SELECT EXISTS(
    SELECT 1 FROM processes
    WHERE work_id = ?
      AND process_type = 'orchestrator'
      AND datetime(heartbeat) >= datetime('now', ? || ' seconds')
) as alive
`

type IsOrchestratorAliveParams struct {
	WorkID  sql.NullString `json:"work_id"`
	Column2 sql.NullString `json:"column_2"`
}

func (q *Queries) IsOrchestratorAlive(ctx context.Context, arg IsOrchestratorAliveParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, isOrchestratorAlive, arg.WorkID, arg.Column2)
	var alive int64
	err := row.Scan(&alive)
	return alive, err
}

const registerProcess = `-- name: RegisterProcess :exec
INSERT INTO processes (id, process_type, work_id, pid, hostname, heartbeat, started_at)
VALUES (?, ?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
ON CONFLICT (id) DO UPDATE SET
    pid = excluded.pid,
    hostname = excluded.hostname,
    heartbeat = CURRENT_TIMESTAMP
`

type RegisterProcessParams struct {
	ID          string         `json:"id"`
	ProcessType string         `json:"process_type"`
	WorkID      sql.NullString `json:"work_id"`
	Pid         int64          `json:"pid"`
	Hostname    string         `json:"hostname"`
}

func (q *Queries) RegisterProcess(ctx context.Context, arg RegisterProcessParams) error {
	_, err := q.db.ExecContext(ctx, registerProcess,
		arg.ID,
		arg.ProcessType,
		arg.WorkID,
		arg.Pid,
		arg.Hostname,
	)
	return err
}

const updateHeartbeat = `-- name: UpdateHeartbeat :exec
UPDATE processes
SET heartbeat = CURRENT_TIMESTAMP
WHERE id = ?
`

func (q *Queries) UpdateHeartbeat(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateHeartbeat, id)
	return err
}
