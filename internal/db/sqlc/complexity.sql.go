// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: complexity.sql

package sqlc

import (
	"context"
	"strings"
)

const cacheComplexity = `-- name: CacheComplexity :exec
REPLACE INTO complexity_cache (bead_id, description_hash, complexity_score, estimated_tokens)
VALUES (?, ?, ?, ?)
`

type CacheComplexityParams struct {
	BeadID          string `json:"bead_id"`
	DescriptionHash string `json:"description_hash"`
	ComplexityScore int64  `json:"complexity_score"`
	EstimatedTokens int64  `json:"estimated_tokens"`
}

func (q *Queries) CacheComplexity(ctx context.Context, arg CacheComplexityParams) error {
	_, err := q.db.ExecContext(ctx, cacheComplexity,
		arg.BeadID,
		arg.DescriptionHash,
		arg.ComplexityScore,
		arg.EstimatedTokens,
	)
	return err
}

const countEstimatedBeads = `-- name: CountEstimatedBeads :one
SELECT COUNT(DISTINCT bead_id) as count
FROM complexity_cache
WHERE bead_id IN (/*SLICE:bead_ids*/?)
`

func (q *Queries) CountEstimatedBeads(ctx context.Context, beadIds []string) (int64, error) {
	query := countEstimatedBeads
	var queryParams []interface{}
	if len(beadIds) > 0 {
		for _, v := range beadIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:bead_ids*/?", strings.Repeat(",?", len(beadIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:bead_ids*/?", "NULL", 1)
	}
	row := q.db.QueryRowContext(ctx, query, queryParams...)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAllCachedComplexity = `-- name: GetAllCachedComplexity :many
SELECT bead_id, complexity_score, estimated_tokens
FROM complexity_cache
`

type GetAllCachedComplexityRow struct {
	BeadID          string `json:"bead_id"`
	ComplexityScore int64  `json:"complexity_score"`
	EstimatedTokens int64  `json:"estimated_tokens"`
}

func (q *Queries) GetAllCachedComplexity(ctx context.Context) ([]GetAllCachedComplexityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCachedComplexity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllCachedComplexityRow{}
	for rows.Next() {
		var i GetAllCachedComplexityRow
		if err := rows.Scan(&i.BeadID, &i.ComplexityScore, &i.EstimatedTokens); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCachedComplexity = `-- name: GetCachedComplexity :one
SELECT complexity_score, estimated_tokens
FROM complexity_cache
WHERE bead_id = ? AND description_hash = ?
`

type GetCachedComplexityParams struct {
	BeadID          string `json:"bead_id"`
	DescriptionHash string `json:"description_hash"`
}

type GetCachedComplexityRow struct {
	ComplexityScore int64 `json:"complexity_score"`
	EstimatedTokens int64 `json:"estimated_tokens"`
}

func (q *Queries) GetCachedComplexity(ctx context.Context, arg GetCachedComplexityParams) (GetCachedComplexityRow, error) {
	row := q.db.QueryRowContext(ctx, getCachedComplexity, arg.BeadID, arg.DescriptionHash)
	var i GetCachedComplexityRow
	err := row.Scan(&i.ComplexityScore, &i.EstimatedTokens)
	return i, err
}
