// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package zellij

import (
	"context"
	"sync"
)

// Ensure, that SessionManagerMock does implement SessionManager.
// If this is not the case, regenerate this file with moq.
var _ SessionManager = &SessionManagerMock{}

// SessionManagerMock is a mock implementation of SessionManager.
//
//	func TestSomethingThatUsesSessionManager(t *testing.T) {
//
//		// make and configure a mocked SessionManager
//		mockedSessionManager := &SessionManagerMock{
//			EnsureSessionWithCommandFunc: func(ctx context.Context, sessionName string, tabName string, cwd string, command string, args []string) (bool, error) {
//				panic("mock out the EnsureSessionWithCommand method")
//			},
//			SessionFunc: func(name string) Session {
//				panic("mock out the Session method")
//			},
//			SessionExistsFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the SessionExists method")
//			},
//		}
//
//		// use mockedSessionManager in code that requires SessionManager
//		// and then make assertions.
//
//	}
type SessionManagerMock struct {
	// EnsureSessionWithCommandFunc mocks the EnsureSessionWithCommand method.
	EnsureSessionWithCommandFunc func(ctx context.Context, sessionName string, tabName string, cwd string, command string, args []string) (bool, error)

	// SessionFunc mocks the Session method.
	SessionFunc func(name string) Session

	// SessionExistsFunc mocks the SessionExists method.
	SessionExistsFunc func(ctx context.Context, name string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// EnsureSessionWithCommand holds details about calls to the EnsureSessionWithCommand method.
		EnsureSessionWithCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SessionName is the sessionName argument value.
			SessionName string
			// TabName is the tabName argument value.
			TabName string
			// Cwd is the cwd argument value.
			Cwd string
			// Command is the command argument value.
			Command string
			// Args is the args argument value.
			Args []string
		}
		// Session holds details about calls to the Session method.
		Session []struct {
			// Name is the name argument value.
			Name string
		}
		// SessionExists holds details about calls to the SessionExists method.
		SessionExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
	}
	lockEnsureSessionWithCommand sync.RWMutex
	lockSession                  sync.RWMutex
	lockSessionExists            sync.RWMutex
}

// EnsureSessionWithCommand calls EnsureSessionWithCommandFunc.
func (mock *SessionManagerMock) EnsureSessionWithCommand(ctx context.Context, sessionName string, tabName string, cwd string, command string, args []string) (bool, error) {
	callInfo := struct {
		Ctx         context.Context
		SessionName string
		TabName     string
		Cwd         string
		Command     string
		Args        []string
	}{
		Ctx:         ctx,
		SessionName: sessionName,
		TabName:     tabName,
		Cwd:         cwd,
		Command:     command,
		Args:        args,
	}
	mock.lockEnsureSessionWithCommand.Lock()
	mock.calls.EnsureSessionWithCommand = append(mock.calls.EnsureSessionWithCommand, callInfo)
	mock.lockEnsureSessionWithCommand.Unlock()
	if mock.EnsureSessionWithCommandFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.EnsureSessionWithCommandFunc(ctx, sessionName, tabName, cwd, command, args)
}

// EnsureSessionWithCommandCalls gets all the calls that were made to EnsureSessionWithCommand.
// Check the length with:
//
//	len(mockedSessionManager.EnsureSessionWithCommandCalls())
func (mock *SessionManagerMock) EnsureSessionWithCommandCalls() []struct {
	Ctx         context.Context
	SessionName string
	TabName     string
	Cwd         string
	Command     string
	Args        []string
} {
	var calls []struct {
		Ctx         context.Context
		SessionName string
		TabName     string
		Cwd         string
		Command     string
		Args        []string
	}
	mock.lockEnsureSessionWithCommand.RLock()
	calls = mock.calls.EnsureSessionWithCommand
	mock.lockEnsureSessionWithCommand.RUnlock()
	return calls
}

// Session calls SessionFunc.
func (mock *SessionManagerMock) Session(name string) Session {
	callInfo := struct {
		Name string
	}{
		Name: name,
	}
	mock.lockSession.Lock()
	mock.calls.Session = append(mock.calls.Session, callInfo)
	mock.lockSession.Unlock()
	if mock.SessionFunc == nil {
		var (
			sessionOut Session
		)
		return sessionOut
	}
	return mock.SessionFunc(name)
}

// SessionCalls gets all the calls that were made to Session.
// Check the length with:
//
//	len(mockedSessionManager.SessionCalls())
func (mock *SessionManagerMock) SessionCalls() []struct {
	Name string
} {
	var calls []struct {
		Name string
	}
	mock.lockSession.RLock()
	calls = mock.calls.Session
	mock.lockSession.RUnlock()
	return calls
}

// SessionExists calls SessionExistsFunc.
func (mock *SessionManagerMock) SessionExists(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockSessionExists.Lock()
	mock.calls.SessionExists = append(mock.calls.SessionExists, callInfo)
	mock.lockSessionExists.Unlock()
	if mock.SessionExistsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.SessionExistsFunc(ctx, name)
}

// SessionExistsCalls gets all the calls that were made to SessionExists.
// Check the length with:
//
//	len(mockedSessionManager.SessionExistsCalls())
func (mock *SessionManagerMock) SessionExistsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockSessionExists.RLock()
	calls = mock.calls.SessionExists
	mock.lockSessionExists.RUnlock()
	return calls
}

// Ensure, that SessionMock does implement Session.
// If this is not the case, regenerate this file with moq.
var _ Session = &SessionMock{}

// SessionMock is a mock implementation of Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked Session
//		mockedSession := &SessionMock{
//			CreateTabWithCommandFunc: func(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error {
//				panic("mock out the CreateTabWithCommand method")
//			},
//			QueryTabNamesFunc: func(ctx context.Context) ([]string, error) {
//				panic("mock out the QueryTabNames method")
//			},
//			SwitchToTabFunc: func(ctx context.Context, name string) error {
//				panic("mock out the SwitchToTab method")
//			},
//			TabExistsFunc: func(ctx context.Context, name string) (bool, error) {
//				panic("mock out the TabExists method")
//			},
//			TerminateAndCloseTabFunc: func(ctx context.Context, tabName string) error {
//				panic("mock out the TerminateAndCloseTab method")
//			},
//		}
//
//		// use mockedSession in code that requires Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// CreateTabWithCommandFunc mocks the CreateTabWithCommand method.
	CreateTabWithCommandFunc func(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error

	// QueryTabNamesFunc mocks the QueryTabNames method.
	QueryTabNamesFunc func(ctx context.Context) ([]string, error)

	// SwitchToTabFunc mocks the SwitchToTab method.
	SwitchToTabFunc func(ctx context.Context, name string) error

	// TabExistsFunc mocks the TabExists method.
	TabExistsFunc func(ctx context.Context, name string) (bool, error)

	// TerminateAndCloseTabFunc mocks the TerminateAndCloseTab method.
	TerminateAndCloseTabFunc func(ctx context.Context, tabName string) error

	// calls tracks calls to the methods.
	calls struct {
		// CreateTabWithCommand holds details about calls to the CreateTabWithCommand method.
		CreateTabWithCommand []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
			// Cwd is the cwd argument value.
			Cwd string
			// Command is the command argument value.
			Command string
			// Args is the args argument value.
			Args []string
			// PaneName is the paneName argument value.
			PaneName string
		}
		// QueryTabNames holds details about calls to the QueryTabNames method.
		QueryTabNames []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SwitchToTab holds details about calls to the SwitchToTab method.
		SwitchToTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// TabExists holds details about calls to the TabExists method.
		TabExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Name is the name argument value.
			Name string
		}
		// TerminateAndCloseTab holds details about calls to the TerminateAndCloseTab method.
		TerminateAndCloseTab []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TabName is the tabName argument value.
			TabName string
		}
	}
	lockCreateTabWithCommand sync.RWMutex
	lockQueryTabNames        sync.RWMutex
	lockSwitchToTab          sync.RWMutex
	lockTabExists            sync.RWMutex
	lockTerminateAndCloseTab sync.RWMutex
}

// CreateTabWithCommand calls CreateTabWithCommandFunc.
func (mock *SessionMock) CreateTabWithCommand(ctx context.Context, name string, cwd string, command string, args []string, paneName string) error {
	callInfo := struct {
		Ctx      context.Context
		Name     string
		Cwd      string
		Command  string
		Args     []string
		PaneName string
	}{
		Ctx:      ctx,
		Name:     name,
		Cwd:      cwd,
		Command:  command,
		Args:     args,
		PaneName: paneName,
	}
	mock.lockCreateTabWithCommand.Lock()
	mock.calls.CreateTabWithCommand = append(mock.calls.CreateTabWithCommand, callInfo)
	mock.lockCreateTabWithCommand.Unlock()
	if mock.CreateTabWithCommandFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.CreateTabWithCommandFunc(ctx, name, cwd, command, args, paneName)
}

// CreateTabWithCommandCalls gets all the calls that were made to CreateTabWithCommand.
// Check the length with:
//
//	len(mockedSession.CreateTabWithCommandCalls())
func (mock *SessionMock) CreateTabWithCommandCalls() []struct {
	Ctx      context.Context
	Name     string
	Cwd      string
	Command  string
	Args     []string
	PaneName string
} {
	var calls []struct {
		Ctx      context.Context
		Name     string
		Cwd      string
		Command  string
		Args     []string
		PaneName string
	}
	mock.lockCreateTabWithCommand.RLock()
	calls = mock.calls.CreateTabWithCommand
	mock.lockCreateTabWithCommand.RUnlock()
	return calls
}

// QueryTabNames calls QueryTabNamesFunc.
func (mock *SessionMock) QueryTabNames(ctx context.Context) ([]string, error) {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockQueryTabNames.Lock()
	mock.calls.QueryTabNames = append(mock.calls.QueryTabNames, callInfo)
	mock.lockQueryTabNames.Unlock()
	if mock.QueryTabNamesFunc == nil {
		var (
			stringsOut []string
			errOut     error
		)
		return stringsOut, errOut
	}
	return mock.QueryTabNamesFunc(ctx)
}

// QueryTabNamesCalls gets all the calls that were made to QueryTabNames.
// Check the length with:
//
//	len(mockedSession.QueryTabNamesCalls())
func (mock *SessionMock) QueryTabNamesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockQueryTabNames.RLock()
	calls = mock.calls.QueryTabNames
	mock.lockQueryTabNames.RUnlock()
	return calls
}

// SwitchToTab calls SwitchToTabFunc.
func (mock *SessionMock) SwitchToTab(ctx context.Context, name string) error {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockSwitchToTab.Lock()
	mock.calls.SwitchToTab = append(mock.calls.SwitchToTab, callInfo)
	mock.lockSwitchToTab.Unlock()
	if mock.SwitchToTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SwitchToTabFunc(ctx, name)
}

// SwitchToTabCalls gets all the calls that were made to SwitchToTab.
// Check the length with:
//
//	len(mockedSession.SwitchToTabCalls())
func (mock *SessionMock) SwitchToTabCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockSwitchToTab.RLock()
	calls = mock.calls.SwitchToTab
	mock.lockSwitchToTab.RUnlock()
	return calls
}

// TabExists calls TabExistsFunc.
func (mock *SessionMock) TabExists(ctx context.Context, name string) (bool, error) {
	callInfo := struct {
		Ctx  context.Context
		Name string
	}{
		Ctx:  ctx,
		Name: name,
	}
	mock.lockTabExists.Lock()
	mock.calls.TabExists = append(mock.calls.TabExists, callInfo)
	mock.lockTabExists.Unlock()
	if mock.TabExistsFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.TabExistsFunc(ctx, name)
}

// TabExistsCalls gets all the calls that were made to TabExists.
// Check the length with:
//
//	len(mockedSession.TabExistsCalls())
func (mock *SessionMock) TabExistsCalls() []struct {
	Ctx  context.Context
	Name string
} {
	var calls []struct {
		Ctx  context.Context
		Name string
	}
	mock.lockTabExists.RLock()
	calls = mock.calls.TabExists
	mock.lockTabExists.RUnlock()
	return calls
}

// TerminateAndCloseTab calls TerminateAndCloseTabFunc.
func (mock *SessionMock) TerminateAndCloseTab(ctx context.Context, tabName string) error {
	callInfo := struct {
		Ctx     context.Context
		TabName string
	}{
		Ctx:     ctx,
		TabName: tabName,
	}
	mock.lockTerminateAndCloseTab.Lock()
	mock.calls.TerminateAndCloseTab = append(mock.calls.TerminateAndCloseTab, callInfo)
	mock.lockTerminateAndCloseTab.Unlock()
	if mock.TerminateAndCloseTabFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.TerminateAndCloseTabFunc(ctx, tabName)
}

// TerminateAndCloseTabCalls gets all the calls that were made to TerminateAndCloseTab.
// Check the length with:
//
//	len(mockedSession.TerminateAndCloseTabCalls())
func (mock *SessionMock) TerminateAndCloseTabCalls() []struct {
	Ctx     context.Context
	TabName string
} {
	var calls []struct {
		Ctx     context.Context
		TabName string
	}
	mock.lockTerminateAndCloseTab.RLock()
	calls = mock.calls.TerminateAndCloseTab
	mock.lockTerminateAndCloseTab.RUnlock()
	return calls
}
