// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package linear

import (
	"context"
	"sync"
)

// Ensure, that LinearClientMock does implement ClientInterface.
// If this is not the case, regenerate this file with moq.
var _ ClientInterface = &LinearClientMock{}

// LinearClientMock is a mock implementation of ClientInterface.
//
//	func TestSomethingThatUsesClientInterface(t *testing.T) {
//
//		// make and configure a mocked ClientInterface
//		mockedClientInterface := &LinearClientMock{
//			GetIssueFunc: func(ctx context.Context, issueIDOrURL string) (*Issue, error) {
//				panic("mock out the GetIssue method")
//			},
//			GetIssueCommentsFunc: func(ctx context.Context, issueID string) ([]Comment, error) {
//				panic("mock out the GetIssueComments method")
//			},
//			ListIssuesFunc: func(ctx context.Context, filters map[string]any) ([]*Issue, error) {
//				panic("mock out the ListIssues method")
//			},
//			SearchIssuesFunc: func(ctx context.Context, searchQuery string, filters map[string]any) ([]*Issue, error) {
//				panic("mock out the SearchIssues method")
//			},
//		}
//
//		// use mockedClientInterface in code that requires ClientInterface
//		// and then make assertions.
//
//	}
type LinearClientMock struct {
	// GetIssueFunc mocks the GetIssue method.
	GetIssueFunc func(ctx context.Context, issueIDOrURL string) (*Issue, error)

	// GetIssueCommentsFunc mocks the GetIssueComments method.
	GetIssueCommentsFunc func(ctx context.Context, issueID string) ([]Comment, error)

	// ListIssuesFunc mocks the ListIssues method.
	ListIssuesFunc func(ctx context.Context, filters map[string]any) ([]*Issue, error)

	// SearchIssuesFunc mocks the SearchIssues method.
	SearchIssuesFunc func(ctx context.Context, searchQuery string, filters map[string]any) ([]*Issue, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetIssue holds details about calls to the GetIssue method.
		GetIssue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IssueIDOrURL is the issueIDOrURL argument value.
			IssueIDOrURL string
		}
		// GetIssueComments holds details about calls to the GetIssueComments method.
		GetIssueComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IssueID is the issueID argument value.
			IssueID string
		}
		// ListIssues holds details about calls to the ListIssues method.
		ListIssues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filters is the filters argument value.
			Filters map[string]any
		}
		// SearchIssues holds details about calls to the SearchIssues method.
		SearchIssues []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SearchQuery is the searchQuery argument value.
			SearchQuery string
			// Filters is the filters argument value.
			Filters map[string]any
		}
	}
	lockGetIssue         sync.RWMutex
	lockGetIssueComments sync.RWMutex
	lockListIssues       sync.RWMutex
	lockSearchIssues     sync.RWMutex
}

// GetIssue calls GetIssueFunc.
func (mock *LinearClientMock) GetIssue(ctx context.Context, issueIDOrURL string) (*Issue, error) {
	callInfo := struct {
		Ctx          context.Context
		IssueIDOrURL string
	}{
		Ctx:          ctx,
		IssueIDOrURL: issueIDOrURL,
	}
	mock.lockGetIssue.Lock()
	mock.calls.GetIssue = append(mock.calls.GetIssue, callInfo)
	mock.lockGetIssue.Unlock()
	if mock.GetIssueFunc == nil {
		var (
			issueOut *Issue
			errOut   error
		)
		return issueOut, errOut
	}
	return mock.GetIssueFunc(ctx, issueIDOrURL)
}

// GetIssueCalls gets all the calls that were made to GetIssue.
// Check the length with:
//
//	len(mockedClientInterface.GetIssueCalls())
func (mock *LinearClientMock) GetIssueCalls() []struct {
	Ctx          context.Context
	IssueIDOrURL string
} {
	var calls []struct {
		Ctx          context.Context
		IssueIDOrURL string
	}
	mock.lockGetIssue.RLock()
	calls = mock.calls.GetIssue
	mock.lockGetIssue.RUnlock()
	return calls
}

// GetIssueComments calls GetIssueCommentsFunc.
func (mock *LinearClientMock) GetIssueComments(ctx context.Context, issueID string) ([]Comment, error) {
	callInfo := struct {
		Ctx     context.Context
		IssueID string
	}{
		Ctx:     ctx,
		IssueID: issueID,
	}
	mock.lockGetIssueComments.Lock()
	mock.calls.GetIssueComments = append(mock.calls.GetIssueComments, callInfo)
	mock.lockGetIssueComments.Unlock()
	if mock.GetIssueCommentsFunc == nil {
		var (
			commentsOut []Comment
			errOut      error
		)
		return commentsOut, errOut
	}
	return mock.GetIssueCommentsFunc(ctx, issueID)
}

// GetIssueCommentsCalls gets all the calls that were made to GetIssueComments.
// Check the length with:
//
//	len(mockedClientInterface.GetIssueCommentsCalls())
func (mock *LinearClientMock) GetIssueCommentsCalls() []struct {
	Ctx     context.Context
	IssueID string
} {
	var calls []struct {
		Ctx     context.Context
		IssueID string
	}
	mock.lockGetIssueComments.RLock()
	calls = mock.calls.GetIssueComments
	mock.lockGetIssueComments.RUnlock()
	return calls
}

// ListIssues calls ListIssuesFunc.
func (mock *LinearClientMock) ListIssues(ctx context.Context, filters map[string]any) ([]*Issue, error) {
	callInfo := struct {
		Ctx     context.Context
		Filters map[string]any
	}{
		Ctx:     ctx,
		Filters: filters,
	}
	mock.lockListIssues.Lock()
	mock.calls.ListIssues = append(mock.calls.ListIssues, callInfo)
	mock.lockListIssues.Unlock()
	if mock.ListIssuesFunc == nil {
		var (
			issuesOut []*Issue
			errOut    error
		)
		return issuesOut, errOut
	}
	return mock.ListIssuesFunc(ctx, filters)
}

// ListIssuesCalls gets all the calls that were made to ListIssues.
// Check the length with:
//
//	len(mockedClientInterface.ListIssuesCalls())
func (mock *LinearClientMock) ListIssuesCalls() []struct {
	Ctx     context.Context
	Filters map[string]any
} {
	var calls []struct {
		Ctx     context.Context
		Filters map[string]any
	}
	mock.lockListIssues.RLock()
	calls = mock.calls.ListIssues
	mock.lockListIssues.RUnlock()
	return calls
}

// SearchIssues calls SearchIssuesFunc.
func (mock *LinearClientMock) SearchIssues(ctx context.Context, searchQuery string, filters map[string]any) ([]*Issue, error) {
	callInfo := struct {
		Ctx         context.Context
		SearchQuery string
		Filters     map[string]any
	}{
		Ctx:         ctx,
		SearchQuery: searchQuery,
		Filters:     filters,
	}
	mock.lockSearchIssues.Lock()
	mock.calls.SearchIssues = append(mock.calls.SearchIssues, callInfo)
	mock.lockSearchIssues.Unlock()
	if mock.SearchIssuesFunc == nil {
		var (
			issuesOut []*Issue
			errOut    error
		)
		return issuesOut, errOut
	}
	return mock.SearchIssuesFunc(ctx, searchQuery, filters)
}

// SearchIssuesCalls gets all the calls that were made to SearchIssues.
// Check the length with:
//
//	len(mockedClientInterface.SearchIssuesCalls())
func (mock *LinearClientMock) SearchIssuesCalls() []struct {
	Ctx         context.Context
	SearchQuery string
	Filters     map[string]any
} {
	var calls []struct {
		Ctx         context.Context
		SearchQuery string
		Filters     map[string]any
	}
	mock.lockSearchIssues.RLock()
	calls = mock.calls.SearchIssues
	mock.lockSearchIssues.RUnlock()
	return calls
}
